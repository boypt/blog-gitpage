<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无证程序员的PT桑</title>
  
  <subtitle>删库跑路中 ╮(╯▽╰)╭</subtitle>
  <link href="https://boypt.github.io/atom.xml" rel="self"/>
  
  <link href="https://boypt.github.io/"/>
  <updated>2022-10-19T02:45:48.998Z</updated>
  <id>https://boypt.github.io/</id>
  
  <author>
    <name>PTさん</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows下较完善的ssh-agent工作流程:WinCryptSSHAgent</title>
    <link href="https://boypt.github.io/2022/08/12/ssh-agent-windows-workflow/"/>
    <id>https://boypt.github.io/2022/08/12/ssh-agent-windows-workflow/</id>
    <published>2022-08-12T05:41:01.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>Win下有很多设计良好的终端软件，但是又有很多使用场景需要联合各种SSH终端使用，如同时用xshell进入主机终端、mysql客户端用plink建立隧道、winscp打开文件管理窗口、wsl2内rsync同步配置文件，在不同的虚拟机、vps环境内使用github的仓库……</p><p>这些软件都有各自的密码密钥管理系统，普通使用方式是生成一个个人key，然后转换成各个格式配置到这些终端平台的配置。</p><p>矛盾在于，如果为了安全，key文件都得使用密码保护，那每次连接主机都要解锁一次key，非常繁琐；如果不使用密码保护key，那到处摆放的key文件似乎是其他程序随手可得，有着很大的隐患。</p><p>解决办法就是配置使用ssh agent，key文件只需让agent单份处理。其他程序通过协议与agent进行通信认证。</p><span id="more"></span><p>这里重点推荐的是<a href="https://github.com/buptczq/WinCryptSSHAgent">WinCryptSSHAgent</a>项目，其实现了一个ssh-agent程序，但是同时兼容pagent, xagent, hyper-v agent……基本常见的SSH软件都能兼容。</p><p>作者是为了使用Yubikey而造的万能兼容层，但是用来管理文件密钥也是非常方便的。<a href="https://www.v2ex.com/t/565640">作者是v2ex网友 swchzq</a>。</p><p>WinCryptSSHAgent的使用很简单，单个exe，运行后就呆在托盘区，没有需要安装、配置的地方。（hyper-v agent需要点一次确认安装），而是要配置其他那些ssh终端程序。</p><h2 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h2><p>首先是要把现有的key添加到WinCryptSSHAgent。跟pagent、xagent等程序的设计不同，WinCryptSSHAgent自己不负责维护key的存放，而仅仅作为一个服务端，密钥的来源一个是操作系统内的密钥Store，另外就是通过agent协议添加key。</p><h3 id="操作系统证书"><a href="#操作系统证书" class="headerlink" title="操作系统证书"></a>操作系统证书</h3><p>打开<code>certmgr.msc</code>内的“个人”类别证书就是可以被WinCryptSSHAgent使用的认证证书（注意需要有私钥）。</p><p><img src="/2022/08/12/ssh-agent-windows-workflow/oscert.png"></p><p>如果是像作者的需求，使用Yubikey直接插USB，那这个key就自动加载进去操作系统，程序就会自动找到了，不需要特殊操作。（也许一些支持通用协议的U盾设备也可以，未尝试）。</p><p>但也可以自己生成自签证书导入到“个人”证书。这个过程需要用到openssl。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">openssl req -subj <span class="string">&#x27;/CN=MyGenKey/O=SELF/C=CN&#x27;</span> -new -newkey rsa:2048 -days 3650 -nodes -x509 -keyout my.key -out my.cer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成Win下可导入的pfx格式</span></span><br><span class="line">openssl pkcs12 -inkey my.key -<span class="keyword">in</span> my.cer -<span class="built_in">export</span> -out mygenkey.pfx</span><br></pre></td></tr></table></figure><p>输出的<code>mygenkey.pfx</code>在Win下双击即可进行导入。导入过程中有个挺有趣的选项，不可更改的：</p><p><img src="/2022/08/12/ssh-agent-windows-workflow/oskeyconfirm.png"></p><p>勾上后每次使用该密钥都会操作系统的弹窗弹窗，来确认当前密钥的使用。</p><p>这种方式只能使用rsa密钥。</p><h3 id="OpenSSH证书"><a href="#OpenSSH证书" class="headerlink" title="OpenSSH证书"></a>OpenSSH证书</h3><p>OpenSSH证书用的是另外一个体系，跟操作系统的证书管理无关。</p><p>WinCryptSSHAgent跟Openssh的ssh-agent服务兼容，使用命名管道跟ssh工具通信，使用<code>ssh-add</code>命令进行密钥的维护。</p><p>如无意外只需要启动WinCryptSSHAgent后就能使用Win10自带的<code>ssh-add</code>命令，不需特殊配置。但有可能出现错误或者冲突，常见是因为Win10自带的OpenSSH-Agent服务正在运行中，需要停止，见下一节WinSSH环境的配置描述。</p><p>使用OpenSSH证书好处是能够使用方便的ed25519证书、兼容已有的证书。而WinCryptSSHAgent则会在右下角弹窗通知每次密钥的使用。比起默认的openssh-agent静默服务，也提供了一定的安全性改善。</p><h2 id="配置各种终端"><a href="#配置各种终端" class="headerlink" title="配置各种终端"></a>配置各种终端</h2><p>要让各种终端程序来使用这个agent，如上述配置<code>ssh-add</code>命令的工作模式，终端程序需要找到agent的通信位置。</p><h3 id="配置WinSSH"><a href="#配置WinSSH" class="headerlink" title="配置WinSSH"></a>配置WinSSH</h3><p>WinSSH是微软维护的openssh分支，已经进入Win10的可选组件，很可能已经默认安装。它会自动找到设置的命名管道跟agent进行通信。</p><p>对于WinSSH重点不是要配置，而且确认Windows自带的openssh-agent服务要停下来，避免跟WinCryptSSHAgent冲突或者混淆了。有些情况下WinCryptSSHAgent<a href="https://github.com/buptczq/WinCryptSSHAgent/issues/29">启动即报错命名管道权限问题</a>，就是这个原因。</p><p>在PowerShell(管理员权限)下运行以下命令确认ssh-agent服务停止，不自动启动。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> ssh<span class="literal">-agent</span> | <span class="built_in">Stop-Service</span></span><br><span class="line"><span class="built_in">Get-Service</span> ssh<span class="literal">-agent</span> | <span class="built_in">Set-Service</span> <span class="literal">-StartupType</span> Manual</span><br></pre></td></tr></table></figure><p>可以用<code>ssh-add -l</code>确认跟WinCryptSSHAgent的通信是否正常。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh<span class="literal">-add</span> <span class="literal">-l</span></span><br><span class="line"></span><br><span class="line">ssh<span class="literal">-add</span> <span class="comment"># 会添加%USERPROFILE%\.ssh\目录内的所有key</span></span><br></pre></td></tr></table></figure><h3 id="配置WSL2"><a href="#配置WSL2" class="headerlink" title="配置WSL2"></a>配置WSL2</h3><p>WSL2内其实是个虚拟机环境，程序建立了个代理隧道，而WSL2内则打开一个socat进行管道转发实现的。</p><p>具体代码还是右键托盘图标，点WSL2弹窗的代码，粘贴到<code>~/.bashrc</code>（或者你用其他shell的话对应的启动配置）。</p><h3 id="配置XShell"><a href="#配置XShell" class="headerlink" title="配置XShell"></a>配置XShell</h3><p>XShell不用配置变量，只需要打个勾。</p><p>从File （文件）- Default Session Properties （默认会话属性），点开Connection - SSH，勾上图中选项。</p><p><img src="/2022/08/12/ssh-agent-windows-workflow/xshell.png"></p><p>这样以后新建的会话都会尝试联系agent。</p><p>已创建的保存会话，需要在会话管理器内设置它们各自的属性（Tips：可以全选然后点属性按钮，一次过更改所有所选会话）。</p><h3 id="Putty-x2F-Plink"><a href="#Putty-x2F-Plink" class="headerlink" title="Putty&#x2F;Plink"></a>Putty&#x2F;Plink</h3><p>P系列的工具使用的是共享内存技术，不需要配置，只要运行就自动找到agent。</p><p>于是WinSCP、Putty、HeidiSQL、sqlyog这些使用putty系列的工具就自动支持了agent。</p><h2 id="开机启动WinCryptSSHAgent"><a href="#开机启动WinCryptSSHAgent" class="headerlink" title="开机启动WinCryptSSHAgent"></a>开机启动WinCryptSSHAgent</h2><p>WinCryptSSHAgent单独exe可以简单地扔到<code>shell:startup</code>启动目录开机自动启动而不用理会。</p><h3 id="使用AutoHotkey来控制添加key"><a href="#使用AutoHotkey来控制添加key" class="headerlink" title="使用AutoHotkey来控制添加key"></a>使用AutoHotkey来控制添加key</h3><p>我习惯使用AutoHotkey来启动一些小工具，于是把启动WinCryptSSHAgent和添加key的逻辑都整合到ahk脚本中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RunWaitOne(command) &#123;</span><br><span class="line">    shell := ComObjCreate(&quot;WScript.Shell&quot;)</span><br><span class="line">    exec := shell.Exec(ComSpec &quot; /C &quot; command)</span><br><span class="line">    return exec.StdOut.ReadAll() . exec.StdErr.ReadAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;SSH KEYAGENT</span><br><span class="line">&gt;!k::</span><br><span class="line">Process,Exist,WinCryptSSHAgent.exe</span><br><span class="line">If (ErrorLevel = 0) &#123;</span><br><span class="line">Run, WinCryptSSHAgent.exe</span><br><span class="line">MsgBox,, Running, Run WinCryptSSHAgent, 1</span><br><span class="line">&#125;</span><br><span class="line">keys := RunWaitOne(&quot;ssh-add -l&quot;)</span><br><span class="line">if InStr(keys, &quot;Error&quot;) &#123;</span><br><span class="line">MsgBox, Failed to run WinCryptSSHAgent:`n`n%keys%</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">Run, ssh-add.exe</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>如此配置后，按下”右Alt+k”，就会开启WinCryptSSHAgent，并出现一个输入key解锁密码终端窗口。</p><h3 id="使用WinSSH-x2F-OpenSSH的自带功能添加key"><a href="#使用WinSSH-x2F-OpenSSH的自带功能添加key" class="headerlink" title="使用WinSSH&#x2F;OpenSSH的自带功能添加key"></a>使用WinSSH&#x2F;OpenSSH的自带功能添加key</h3><p>OpenSSH的配置文件<code>%USERPROFILE%\.ssh\config</code>（或wsl内<code>~/.ssh/config</code>）可以加上这么一段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  HostkeyAlgorithms +ssh-rsa</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  AddKeysToAgent yes</span><br></pre></td></tr></table></figure><p>重点是<code>AddKeysToAgent yes</code>这句，如果agent里面并没有key，ssh会读取<code>.ssh/id_xxx</code>，如果解锁认证成功，就顺便通过agent协议把这个key添加到agent。</p><p>如果主要使用VSCode的SSH Remote功能，那首次连接时候解锁一次密钥，密钥就呆在agent中了，非常方便。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Win下有很多设计良好的终端软件，但是又有很多使用场景需要联合各种SSH终端使用，如同时用xshell进入主机终端、mysql客户端用plink建立隧道、winscp打开文件管理窗口、wsl2内rsync同步配置文件，在不同的虚拟机、vps环境内使用github的仓库……&lt;/p&gt;
&lt;p&gt;这些软件都有各自的密码密钥管理系统，普通使用方式是生成一个个人key，然后转换成各个格式配置到这些终端平台的配置。&lt;/p&gt;
&lt;p&gt;矛盾在于，如果为了安全，key文件都得使用密码保护，那每次连接主机都要解锁一次key，非常繁琐；如果不使用密码保护key，那到处摆放的key文件似乎是其他程序随手可得，有着很大的隐患。&lt;/p&gt;
&lt;p&gt;解决办法就是配置使用ssh agent，key文件只需让agent单份处理。其他程序通过协议与agent进行通信认证。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://boypt.github.io/categories/linux/"/>
    
    
    <category term="windows" scheme="https://boypt.github.io/tags/windows/"/>
    
    <category term="ssh" scheme="https://boypt.github.io/tags/ssh/"/>
    
    <category term="ssh-agent" scheme="https://boypt.github.io/tags/ssh-agent/"/>
    
  </entry>
  
  <entry>
    <title>树莓派使用硬件RTC时钟</title>
    <link href="https://boypt.github.io/2021/10/22/raspberry-rtc/"/>
    <id>https://boypt.github.io/2021/10/22/raspberry-rtc/</id>
    <published>2021-10-22T05:19:03.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派等各种派，往往都不带硬件时钟，在断电、离线网络等情况下是无法以实际时间运行系统和程序的。解决方式是安装一个RTC时钟模块，成本也不高，但是软硬件各方面可能有一些坑要踩一下。</p><p><img src="/2021/10/22/raspberry-rtc/ds1307.png" alt="DS1307模块"></p><span id="more"></span><h2 id="硬件模块"><a href="#硬件模块" class="headerlink" title="硬件模块"></a>硬件模块</h2><p>硬件上可以选择上图这种专门为raspberry 40pin 接口使用的小模块，成本较高（淘宝售价10元+），但是组装性能好一些，跟主板本身能紧密连接。性能方面，ds1307其实只是个计数芯片，实际走时是通过外部32768Hz的晶振，精度可能不会十分准确。另外这个模块扣具一下子占了10个pin口，其中包括模块通信使用的i2c、电源5v&#x2F;3.3v，以及常用调试的uart ttl口，不过也引出了插针，调试倒不成问题。</p><p>有性能更好的ds3231模块，芯片内部自带晶振，受干扰和晶振质量影响较小，走时较为准确，不过成本高一些。</p><p><img src="/2021/10/22/raspberry-rtc/ds3231.jpg" alt="DS3231模块"></p><p>如果使用更通用的模块，ds1307甚至有卖2块钱的小模块，只是需要另外连接引线。其实这小小模块的性能考虑还挺多的，比如有些模块提供电池充电等等。</p><h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><p>上述这些RTC模块其实使用了i2c通信接口，而树莓派对应的系统基本都要对应的内核模块支持，要驱动起来不算麻烦。</p><p>比如在raspberry 4B，只需要配置<code>/boot/config.txt</code> (具体文档在<code>/boot/overlays/README</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dtoverlay=i2c-rtc,ds1307 </span><br><span class="line">dtparam=i2c=on</span><br></pre></td></tr></table></figure><p>具体不通型号稍有区别，可以看<a href="https://wiki.52pi.com/index.php/DS1307_RTC_Module_with_BAT_for_Raspberry_Pi_SKU%3A_EP-0059">51pi</a>。</p><p>但是根据使用系统的不通，发现并不好用，虽然驱动加上了，系统时间并没有从硬件同步进来（也许是centos系列系统的问题？包括树莓自己的Raspberry Pi OS）。</p><p>查到一个方法是写自己的systemd服务，脚本控制模块加载和同步时间。</p><p><a href="https://github.com/scottlamb/moonfire-nvr/wiki/System-setup#realtime-clock-on-raspberry-pi">addon-hwclock.service</a></p><p>对应的脚本和service如下：</p><p>脚本 <code>/etc/addon-hwclock</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Use add-on hardware RTC module. See /etc/systemd/system/addon-hwclock.service.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Be verbose so failures can be examined with `journalctl --unit addon-hwclock`.</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o xtrace</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;start&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Load the kernel modules needed by the RTC.</span></span><br><span class="line">    <span class="comment"># udevd might do some/all of this later, but we want it now (before root fsck).</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> i2c_bcm2835 rtc_ds1307; <span class="keyword">do</span> /sbin/modprobe <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Potentially useful debugging commands. Uncomment to taste.</span></span><br><span class="line">    <span class="comment"># /usr/bin/dtc --in-format fs /proc/device-tree</span></span><br><span class="line">    <span class="comment"># /usr/sbin/i2cdetect -y 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># echo ds3231 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device</span></span><br><span class="line">    <span class="built_in">echo</span> ds1307 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Debugging, again.</span></span><br><span class="line">    <span class="comment"># /usr/bin/dtc --in-format fs /proc/device-tree</span></span><br><span class="line">    <span class="comment"># /usr/sbin/i2cdetect -y 1</span></span><br><span class="line"></span><br><span class="line">    /sbin/hwclock --hctosys --utc</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;stop&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    /sbin/hwclock --systohc --utc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>Service <code>/etc/systemd/system/addon-hwclock.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Add-on hardware RTC module</span><br><span class="line">DefaultDependencies=no</span><br><span class="line"></span><br><span class="line"># Run after fake-hwclock so it doesn&#x27;t override the time set from the real hwclock.</span><br><span class="line">After=fake-hwclock.service</span><br><span class="line"></span><br><span class="line"># Filesystems record their last mount time; fsck complains if it&#x27;s in the future.</span><br><span class="line"># Run before the first fsck to avoid this. Earlier in the boot process is better anyway.</span><br><span class="line">Before=sysinit.target systemd-fsck-root.service time-set.target</span><br><span class="line">Conflicts=shutdown.target</span><br><span class="line"></span><br><span class="line"># Note because of the WantedBy=sysinit.target, the system will boot into</span><br><span class="line"># emergency mode on failure. Be a little defensive with the ConditionFileIsExecutable</span><br><span class="line"># to avoid that annoying failure mode.</span><br><span class="line">ConditionFileIsExecutable=/etc/addon-hwclock</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">ExecStart=/etc/addon-hwclock start</span><br><span class="line">ExecStop=/etc/addon-hwclock stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sysinit.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后激活使用，把当前时间写入到模块（–systohc）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> a+rx /etc/addon-hwclock</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> addon-hwclock.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh -c <span class="string">&#x27;for i in i2c_bcm2835 rtc_ds1307; do /sbin/modprobe $i; done&#x27;</span></span><br><span class="line">sh -c <span class="string">&#x27;echo ds1307 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device&#x27;</span></span><br><span class="line">/sbin/hwclock --systohc --utc</span><br></pre></td></tr></table></figure><p>然后就可以重启检查效果了。</p><h2 id="跳坑"><a href="#跳坑" class="headerlink" title="跳坑"></a>跳坑</h2><h3 id="电源稳定性"><a href="#电源稳定性" class="headerlink" title="电源稳定性"></a>电源稳定性</h3><p>发现虽然这么个小模块，也是对电源有要求的，使用主机USB、1A小电源启动树莓派后，会间歇性找不到RTC模块，或者各种其他报错。</p><p>换成5V 2A的电源就稳定了。折腾了不少时间。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>i2c是个总线接口，可以连接很多设备，分别使用不同的地址进行通信。</p><p>使用<code>i2cdetect -y 1</code>可以扫描检测所有i2c设备。</p><p>比如ds1307模块使用的地址是0x68，上述扫描时候如果发现对应地址有设备就会显示对应的数字。</p><p>但是如果已经加载好驱动模块，对应地址就显示<code>UU</code>。</p><h3 id="关于fake-hwclock服务"><a href="#关于fake-hwclock服务" class="headerlink" title="关于fake-hwclock服务"></a>关于fake-hwclock服务</h3><p>fake-hwclock其实是树莓派系统默认对于不存在硬件时钟时候，把关机时候的时间写入到文件，开机时候重新读取，而不是从1970年开始重新算的时间。</p><p>不少资料说使用rtc模块后应该删除这个服务，其实不必须的，不影响上述模块的工作流程。还能避免在临时断开模块时候设备启动的时间又从1970开始的问题。 </p><h3 id="硬件连线"><a href="#硬件连线" class="headerlink" title="硬件连线"></a>硬件连线</h3><p>使用硬件连线模块时候，注意是ds1307用的是5v，DS3231 和 PCF8523是用3.3v的。</p><p>DS3231 和 PCF8523 使用3.3v供电。<br>** Vin 连接至 Pin 1 **<br>** SDA 连接到 Pin 3 **<br>** SCL 连接到 Pin 5 **<br>** GND 连接到引脚 6 **</p><p><img src="/2021/10/22/raspberry-rtc/3v3.png" alt="DS3231 3.3v"></p><p>DS1307 使用5v供电。</p><p><img src="/2021/10/22/raspberry-rtc/5v.png" alt="DS1307 5V"></p><p>** Vin 连接至 Pin 4 **<br>** SDA 连接到 Pin 3 **<br>** SCL 连接到 Pin 5 **<br>** GND 连接到引脚 6 **</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;树莓派等各种派，往往都不带硬件时钟，在断电、离线网络等情况下是无法以实际时间运行系统和程序的。解决方式是安装一个RTC时钟模块，成本也不高，但是软硬件各方面可能有一些坑要踩一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/22/raspberry-rtc/ds1307.png&quot; alt=&quot;DS1307模块&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://boypt.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://boypt.github.io/tags/linux/"/>
    
    <category term="raspberry" scheme="https://boypt.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>用Nginx作为Webdav服务器</title>
    <link href="https://boypt.github.io/2021/09/30/nginx-as-webdav/"/>
    <id>https://boypt.github.io/2021/09/30/nginx-as-webdav/</id>
    <published>2021-09-30T08:26:23.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>提供Webdav服务，本来有rclone 、 go-webdav等使用golang的服务端，跑起来是非常方便的，但是如果设备是CPU性能较低内存较小的比如MTK7621，就分分钟卡死整个系统。</p><p>研究后决定用nginx提供webdav。</p><span id="more"></span><p>Nginx的Webdav支持是比较分裂的，一个是官方自带的<a href="http://nginx.org/en/docs/http/ngx_http_dav_module.html">ngx_http_dav_module</a>但是功能不齐全，需要一个第三方模块<a href="https://github.com/arut/nginx-dav-ext-module">nginx-dav-ext-module</a>。不过在Openwrt里面直接<code>opkg install nginx-all-module</code>，是全带了适合的模块的了。</p><p>经测试，nginx提供的webdav访问响应明显好于rclone提供的。大概是MIPS价格下，golang的效率还是受限了。</p><p>直接上配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">dav_ext_lock_zone zone=davlock:10m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       8081 default_server;</span><br><span class="line">    listen       [::]:8081 default_server;</span><br><span class="line">    listen       8083 default_server ssl;</span><br><span class="line">    listen       [::]:8083 default_server ssl;</span><br><span class="line">    ssl_certificate /etc/ssl/my.domain/fullchain.cer;</span><br><span class="line">    ssl_certificate_key /etc/ssl/my.domain/my.domain.key;</span><br><span class="line">    ssl_protocols TLSv1.3 TLSv1.2;</span><br><span class="line">    ssl_ciphers EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA512:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:ECDH+AESGCM:ECDH+AES256:DH+AESGCM:DH+AES256:RSA+AESGCM:!aNULL:!eNULL:!LOW:!RC4:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS;</span><br><span class="line">    ssl_session_cache shared:TLS:2m;</span><br><span class="line">    ssl_buffer_size 4k;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    root /mnt;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        # enable creating directories without trailing slash</span><br><span class="line">        set $x $uri$request_method;</span><br><span class="line">        if ($x ~ [^/]MKCOL$) &#123;</span><br><span class="line">            rewrite ^(.*)$ $1/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client_body_temp_path /mnt/sda1/.nginxtemp 2;</span><br><span class="line">        autoindex on;</span><br><span class="line">        dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">        dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;</span><br><span class="line">        dav_ext_lock zone=davlock;</span><br><span class="line">        dav_access user:rw group:rw all:rw;</span><br><span class="line">        create_full_put_path on;</span><br><span class="line">        client_max_body_size 0M;</span><br><span class="line">        auth_basic &quot;Authorized Users Only&quot;;</span><br><span class="line">        auth_basic_user_file /etc/nginx/webdavpasswd;</span><br><span class="line">        satisfy any;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置里面8081端口提供了http、8083提供了tls的https。</p><p>需要注意<code>client_body_temp_path</code>的参数，在webdav上传适合nginx会把临时文件先放到这个路径，然后才转移到实际上传路径。最好放在相同分区的目录下。</p><p><code>auth_basic_user_file</code>是普通的http auth格式。 </p><p>因为开启了<code>autoindex on;</code>，即使不用webdav客户端，直接浏览器访问也是能够下载对应目录和文件的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提供Webdav服务，本来有rclone 、 go-webdav等使用golang的服务端，跑起来是非常方便的，但是如果设备是CPU性能较低内存较小的比如MTK7621，就分分钟卡死整个系统。&lt;/p&gt;
&lt;p&gt;研究后决定用nginx提供webdav。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://boypt.github.io/tags/linux/"/>
    
    <category term="networking" scheme="https://boypt.github.io/tags/networking/"/>
    
    <category term="webdav" scheme="https://boypt.github.io/tags/webdav/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN 客户端间选择性互通</title>
    <link href="https://boypt.github.io/2021/09/28/openvpn-client2client-limit/"/>
    <id>https://boypt.github.io/2021/09/28/openvpn-client2client-limit/</id>
    <published>2021-09-28T06:33:08.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>OpenVPN服务器中若配置了<code>client-to-client</code>, 终端之间是无限制互通的。</p><span id="more"></span><p>配置文档中如此描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment this directive to allow different</span><br><span class="line"># clients to be able to &quot;see&quot; each other.</span><br><span class="line"># By default, clients will only see the server.</span><br><span class="line"># To force clients to only see the server, you</span><br><span class="line"># will also need to appropriately firewall the</span><br><span class="line"># server&#x27;s TUN/TAP interface.</span><br><span class="line">; client-to-client</span><br></pre></td></tr></table></figure><p>如果想要指定特定终端能互通，特定不能通，不能打开这个选项。</p><p>首先要开启配置<code>topology subnet</code>。</p><p>此时服务器的tun0上是可以看到终端所有数据包了，即终端数据会进入服务器的内核IP Stack。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOF</span><br><span class="line"># for openvpn client packet forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>最后通过iptables的FORWARD规则，屏蔽特定不允许互通的网段。即可实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i tun0 -o tun0 -s 10.15.100.0/24 -d 10.15.100.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>原理摘自<a href="https://serverfault.com/questions/736274/openvpn-client-to-client">Stackoverflow一篇帖子</a>，摘抄如下。</p><p>If <code>client-to-client</code> is enabled, the VPN server forwards client-to-client packets internally without sending them to the IP layer of the host (i.e. to the kernel). The host networking stack does not see those packets at all.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">          .-------------------.</span><br><span class="line">          | IP Layer          |</span><br><span class="line">          &#x27;-------------------&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          .-------------------.</span><br><span class="line">          | TUN device (tun0) |</span><br><span class="line">          &#x27;-------------------&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          .-------------------.</span><br><span class="line">          | OpenVPN server    |</span><br><span class="line">          &#x27;-------------------&#x27;</span><br><span class="line">            ^           |</span><br><span class="line">         1  |           |  2   </span><br><span class="line">            |           v</span><br><span class="line">.----------------.  .----------------.</span><br><span class="line">| Client a       |  | Client b       |</span><br><span class="line">&#x27;----------------&#x27;  &#x27;----------------&#x27;</span><br></pre></td></tr></table></figure><p>If client-to-client is disabled, the packets from a client to another client go through the host IP layer (iptables, routing table, etc.) of the machine hosting the VPN server: if IP forwarding is enabled, the host might forward the packet (using its routing table) again to the TUN interface and the VPN daemon will forward the packet to the correct client inside the tunnel.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">          .-------------------.</span><br><span class="line">          | IP Layer          |  (4) routing, firewall, NAT, etc.</span><br><span class="line">          &#x27;-------------------&#x27;      (iptables, nftables, conntrack, tc, etc.)</span><br><span class="line">             ^          |</span><br><span class="line">         3   |          |  5</span><br><span class="line">             |          v</span><br><span class="line">          .-------------------.</span><br><span class="line">          | TUN device (tun0) |</span><br><span class="line">          &#x27;-------------------&#x27;</span><br><span class="line">            ^           |</span><br><span class="line">         2  |           |  6  </span><br><span class="line">            |           v</span><br><span class="line">          .-------------------.</span><br><span class="line">          | OpenVPN server    |</span><br><span class="line">          &#x27;-------------------&#x27;</span><br><span class="line">            ^           |</span><br><span class="line">         1  |           |  7  </span><br><span class="line">            |           v</span><br><span class="line">.----------------.  .----------------.</span><br><span class="line">| Client a       |  | Client b       |</span><br><span class="line">&#x27;----------------&#x27;  &#x27;----------------&#x27;</span><br></pre></td></tr></table></figure><p>In this case (client-to-client disabled), you can block the client-to-client packets using iptables:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i tun0 -o tun0 -j DROP</span><br></pre></td></tr></table></figure><p>where tun0 is your VPN interface.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenVPN服务器中若配置了&lt;code&gt;client-to-client&lt;/code&gt;, 终端之间是无限制互通的。&lt;/p&gt;</summary>
    
    
    
    <category term="networking" scheme="https://boypt.github.io/categories/networking/"/>
    
    
    <category term="linux" scheme="https://boypt.github.io/tags/linux/"/>
    
    <category term="networking" scheme="https://boypt.github.io/tags/networking/"/>
    
    <category term="openvpn" scheme="https://boypt.github.io/tags/openvpn/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker的Openwrt SDK编译环境</title>
    <link href="https://boypt.github.io/2021/09/09/openwrtsdk/"/>
    <id>https://boypt.github.io/2021/09/09/openwrtsdk/</id>
    <published>2021-09-09T05:41:11.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>Openwrt的编译环境算是比较易用的，只要下载对应设备的sdk包，解压就能使用。</p><p>不过一些基础程序包还是依赖原生系统，如果原系统的版本出现冲突，又会有麻烦。不过openwrt官方维护的各种架构和型号的docker镜像，基本都是特定版本的debian，统一化了环境，这就方便了许多。</p><span id="more"></span><h2 id="例子：-给openwrt-21-02编译一个aria2-1-36"><a href="#例子：-给openwrt-21-02编译一个aria2-1-36" class="headerlink" title="例子： 给openwrt 21.02编译一个aria2 1.36"></a>例子： 给openwrt 21.02编译一个aria2 1.36</h2><p>openwrt 21.02 版本时候，aria2 才1.35，所以正式版仓库里面不会有1.36，可以自己编一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 拖回一个镜像，这里以一个mtk 7621设备为例子</span><br><span class="line">docker pull openwrtorg/sdk:mipsel_24kc-openwrt-21.02</span><br><span class="line"></span><br><span class="line"># 开一个临时镜像一用，在里面编译完就不要了，所以用上了--rm，</span><br><span class="line"># 里面的终端做任何事情只要退了就一切消失</span><br><span class="line">docker run -it --rm openwrtorg/sdk:mipsel_24kc-openwrt-21.02 /bin/bash</span><br><span class="line"></span><br><span class="line"># 里面是个debian10的普通用户，但是vim什么的都没有，随便搞一下</span><br><span class="line"></span><br><span class="line">sudo sed -i &#x27;s|deb.debian.org|mirrors.aliyun.com|;s|security.debian.org|mirrors.aliyun.com|&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update </span><br><span class="line"></span><br><span class="line"># lrzsz是为了方便跟本地传文件，不然编译完要回去用docker copy命令拷贝多麻烦，</span><br><span class="line"># sz 一下就能把容器里面的文件发到终端了</span><br><span class="line">sudo apt install vim-tiny lrzsz</span><br><span class="line"></span><br><span class="line">#普通用户的根目录就是openwrt的编译目录</span><br><span class="line"></span><br><span class="line">cp feeds.conf.default feeds.conf</span><br><span class="line">vim feeds.conf</span><br><span class="line"># 复制一份配置, 因为aria2只在packages仓库，因此只保留一行</span><br><span class="line"># src-git packages https://git.openwrt.org/feed/packages.git^65057dcbb5de371503c9159de3d45824bec482e0</span><br><span class="line"># 又因为后面的^65057...是21.02版本的id，我需要最新版的，去掉。</span><br><span class="line"># 就变成 src-git packages https://git.openwrt.org/feed/packages.git</span><br><span class="line"></span><br><span class="line"># 从这里开始是需要联网操作的，如果环境在墙内需要设置代理，随便指定个http代理的就好</span><br><span class="line">export http_proxy=http://192.168.0.99:3128</span><br><span class="line"></span><br><span class="line">./scripts/feeds update packages</span><br><span class="line"># feeds 命令是同步仓库里面的包源码到本地</span><br><span class="line"></span><br><span class="line">./scripts/feeds install aria2</span><br><span class="line"># 因为aria2 1.36已经在仓库里面了，不需要改源码</span><br><span class="line"># 如果仓库没及时更新，可以修改package/feeds/packages/aria2/Makefile</span><br><span class="line"></span><br><span class="line"># 直接开片</span><br><span class="line">make package/aria2/compile</span><br><span class="line"></span><br><span class="line"># 期间会出现menuconfig，需要找到选择编译模块等等的</span><br><span class="line"># 完成后直接在bin目录里面找到对应的ipk，以及对应的依赖</span><br><span class="line"># 打包后sz出来发到设备里面安装即可</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Openwrt的编译环境算是比较易用的，只要下载对应设备的sdk包，解压就能使用。&lt;/p&gt;
&lt;p&gt;不过一些基础程序包还是依赖原生系统，如果原系统的版本出现冲突，又会有麻烦。不过openwrt官方维护的各种架构和型号的docker镜像，基本都是特定版本的debian，统一化了环境，这就方便了许多。&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="openwrt" scheme="https://boypt.github.io/tags/openwrt/"/>
    
    <category term="docker" scheme="https://boypt.github.io/tags/docker/"/>
    
    <category term="sdk" scheme="https://boypt.github.io/tags/sdk/"/>
    
  </entry>
  
  <entry>
    <title>无线网卡AR5B22的5G频段</title>
    <link href="https://boypt.github.io/2021/09/07/ar5b22/"/>
    <id>https://boypt.github.io/2021/09/07/ar5b22/</id>
    <published>2021-09-07T06:30:04.000Z</published>
    <updated>2022-10-19T02:45:48.994Z</updated>
    
    <content type="html"><![CDATA[<p>AR5B22的无线芯片是AR9462。AR5B22在win7时代算是个挺热门的“神卡”，因为能用Killer的驱动颇有名气。但是作为早已停产的芯片和产品，这网卡在Win10下已经有点跟不上。</p><span id="more"></span><p>主要体现在Wifi 5G频段上，因为当时中国的5G频段还是只有149~161频，所以这个网卡也只能搜到这几个频段的。倒不是他连不上，完全是因为老旧的驱动代码限制了。</p><p>多次摸索后，需要手动选择另外的驱动，才能解除。</p><h1 id="安装高通驱动"><a href="#安装高通驱动" class="headerlink" title="安装高通驱动"></a>安装高通驱动</h1><p>首先下载安装高通的驱动大补包 ath-drivers.eu</p><p><a href="https://www.ath-drivers.eu/download-driver-nr-343-for-atheros-AR9462-and-Windows10.html">Qualcomm Atheros wireless driver 10.0.3.456 for AR9462 and Windows 10 </a></p><p>安装后手动更改设备的驱动，手动选择<code>11a|b|g|n Wireless Lan Mini-PCI Express Adapter</code>，系统提示不兼容也要强上。</p><p>如图所示，实测这两个型号驱动都能使用。</p><p><img src="/2021/09/07/ar5b22/11abgn1.png"></p><p><img src="/2021/09/07/ar5b22/11abgn2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AR5B22的无线芯片是AR9462。AR5B22在win7时代算是个挺热门的“神卡”，因为能用Killer的驱动颇有名气。但是作为早已停产的芯片和产品，这网卡在Win10下已经有点跟不上。&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="wifi" scheme="https://boypt.github.io/tags/wifi/"/>
    
    <category term="wireless" scheme="https://boypt.github.io/tags/wireless/"/>
    
    <category term="ar5b22" scheme="https://boypt.github.io/tags/ar5b22/"/>
    
  </entry>
  
  <entry>
    <title>大麦DW33D刷机总结帖</title>
    <link href="https://boypt.github.io/2021/09/07/dw33d/"/>
    <id>https://boypt.github.io/2021/09/07/dw33d/</id>
    <published>2021-09-07T05:44:04.000Z</published>
    <updated>2022-10-19T02:45:48.994Z</updated>
    
    <content type="html"><![CDATA[<p>大麦DW33D已经是很多年前的路由，都2021了可能配置上的有点过时（1750MAC Wifi+全千兆+高通QCA9558），但是如果本着性价比出发的话，目前某鱼上不到50一台的性价比确实还行的。</p><span id="more"></span><p>总结一下刷机要点。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>dw33d内部有三个存储空间（可理解为硬盘），SPI-NOR(16M)、 NAND(128M)、 TF卡（16G）。</p><p>原厂固件是在NOR上的，一些旧版（lede 17.x）也是设计刷到NOR上，这类固件称为(ath1x)。BREED默认也是刷到NOR，启动也是NOR。</p><p>后来openwrt把dw33d纳入官方支持时候，改成使用NAND作为固件区域，并称为<code>ath79</code>，或者nand固件。</p><p>旧版固件虽然刷入简单（可以Breed WEB页面直刷），但是可用空间非常有限。</p><p>nand固件的刷入较为复杂，但是有足够大的存储空间（可用空间70M+），可以安装很多可选插件。</p><p>Breed虽然在dw33d上工作不完美，但是还是比u-boot简化一丢丢。</p><p>刷机方法可以是u-boot，连接TTL线操作；也可以不拆外壳，telnet操作；</p><h1 id="简洁刷机"><a href="#简洁刷机" class="headerlink" title="简洁刷机"></a>简洁刷机</h1><p>Breed刷Nand看起来很复杂，其实总共3个步骤：</p><ul><li>Breed设置环境变量</li><li>PC开启http服务器</li><li>Breed Telnet下载并写入固件。</li></ul><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>目的是让breed默认从nand开始启动，<code>bank 0</code>是nand空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">envconf 0x6000000 0x20000</span><br><span class="line">env set network.ipaddr 192.168.1.1</span><br><span class="line">env set network.netmask 255.255.255.0</span><br><span class="line">env set autoboot.disabled 0</span><br><span class="line">env set autoboot.delay 5</span><br><span class="line">env set autoboot.command &quot;boot flash bank 0 0x0&quot;</span><br><span class="line">env save</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PC上开启HTTP服务器"><a href="#PC上开启HTTP服务器" class="headerlink" title="PC上开启HTTP服务器"></a>PC上开启HTTP服务器</h2><p>确保dw33d的地址能访问到pc, 例子中pc的地址是192.168.0.254</p><h2 id="Breed-下载固件"><a href="#Breed-下载固件" class="headerlink" title="Breed 下载固件"></a>Breed 下载固件</h2><p>此处原理是，breed命令的wget下载指定地址的文件，放到地址0x80000000。<br>然后需要注意提示下载的长度(0xd00000)</p><p>然后擦除对应长度的nand空间，然后从0x80000000复制写入特定长度的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.0.254/firmware/dw33d-factory.bin</span><br><span class="line">##### 注意长度的0xd00000</span><br><span class="line">#####-&gt; Length: 13631488/0xd00000 (13MB) [application/octet-stream]</span><br><span class="line">flash bank 0 erase 0x0 0xd00000</span><br><span class="line">flash bank 0 write 0x0 0x80000000 0xd00000</span><br></pre></td></tr></table></figure><h1 id="关于升级"><a href="#关于升级" class="headerlink" title="关于升级"></a>关于升级</h1><p>测试过从21.02-rc升级到21.02正式版，直接web升级没出现问题。</p><p>但是软件包需要重装，常用工具curl&#x2F;tcpdump之类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大麦DW33D已经是很多年前的路由，都2021了可能配置上的有点过时（1750MAC Wifi+全千兆+高通QCA9558），但是如果本着性价比出发的话，目前某鱼上不到50一台的性价比确实还行的。&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="wifi" scheme="https://boypt.github.io/tags/wifi/"/>
    
    <category term="rouer" scheme="https://boypt.github.io/tags/rouer/"/>
    
    <category term="dw33d" scheme="https://boypt.github.io/tags/dw33d/"/>
    
  </entry>
  
  <entry>
    <title>迅雷下载宝OPENWRT官方版本折腾SD卡扩容</title>
    <link href="https://boypt.github.io/2021/09/07/thundercloud/"/>
    <id>https://boypt.github.io/2021/09/07/thundercloud/</id>
    <published>2021-09-07T05:32:54.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>迅雷下载宝使用OPENWRT 21.02正式版</p><span id="more"></span><p>Breed下直接刷入本来直接可用，没有太多需要折腾的。但是空间不大，而下载宝有个SD卡槽，可以折腾ExtRoot扩容。</p><p><a href="https://openwrt.org/docs/guide-user/additional-software/extroot_configuration">官方文档</a></p><h1 id="一些关键步骤"><a href="#一些关键步骤" class="headerlink" title="一些关键步骤"></a>一些关键步骤</h1><p>替换源、安装必要内核模块</p><p>我把sd卡分区后格式化成f2fs了，官方里面推荐ext4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s|downloads.openwrt.org|mirrors.aliyun.com/openwrt|&#x27;</span> /etc/opkg/distfeeds.conf</span><br><span class="line">sed -i <span class="string">&#x27;s|downloads.openwrt.org|mirrors.tencent.com/openwrt|&#x27;</span> /etc/opkg/distfeeds.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opkg update</span><br><span class="line">opkg install block-mount kmod-fs-f2fs kmod-fs-ext4 kmod-usb-storage kmod-usb-ohci kmod-usb-uhci fdisk kmod-sdhci-mt7620 f2fs-tools f2fsck mkf2fs</span><br></pre></td></tr></table></figure><p>以下才是关键步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">block info</span><br><span class="line"><span class="comment"># 查到具体分区的uuid， 对应替换</span></span><br><span class="line"></span><br><span class="line">uci -q delete fstab.rwm</span><br><span class="line">uci <span class="built_in">set</span> fstab.rwm=<span class="string">&quot;mount&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.rwm.device=<span class="string">&quot;/dev/mtdblock6&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.rwm.target=<span class="string">&quot;/rwm&quot;</span></span><br><span class="line">uci commit fstab</span><br><span class="line"></span><br><span class="line">uci -q delete fstab.overlay</span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay=<span class="string">&quot;mount&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.uuid=<span class="string">&quot;010624d4-e8a2-432c-8fde-b23cf18ebe20&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.target=<span class="string">&quot;/overlay&quot;</span></span><br><span class="line">uci commit fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#迁移数据</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp/cproot</span><br><span class="line">mount --<span class="built_in">bind</span> /overlay /tmp/cproot</span><br><span class="line">mount /dev/mmcblk0p1 /mnt</span><br><span class="line">tar -C /tmp/cproot -cvf - . | tar -C /mnt -xf -</span><br><span class="line">umount /tmp/cproot /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="关于升级"><a href="#关于升级" class="headerlink" title="关于升级"></a>关于升级</h1><p>升级后这些配置都没了，都得重新搞。sd卡的分区没必要格式化重来，但是以上步骤的数据迁移还是要做，升级后overlay的文件会有更新。内核<code>/lib/modules</code>对应版本的目录可以删除。</p><p>最重要一点，要删掉<code>.extroot-uuid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">rm -f /mnt/.extroot-uuid /mnt/etc/.extroot-uuid</span><br><span class="line">umount /mnt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>见官方文档的Troubleshooting  block: extroot: UUID mismatch</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迅雷下载宝使用OPENWRT 21.02正式版&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="openwrt" scheme="https://boypt.github.io/tags/openwrt/"/>
    
    <category term="xunlei" scheme="https://boypt.github.io/tags/xunlei/"/>
    
  </entry>
  
  <entry>
    <title>日本 au home spot cube 水晶盒子Wifi路由</title>
    <link href="https://boypt.github.io/2021/09/07/auhome-spot-cube/"/>
    <id>https://boypt.github.io/2021/09/07/auhome-spot-cube/</id>
    <published>2021-09-07T02:34:27.000Z</published>
    <updated>2022-10-19T02:45:48.994Z</updated>
    
    <content type="html"><![CDATA[<p>au home spot cube 是个挺低配的小路由，可能是最便宜的带5G频段（802.11n，aka WIFI 4）的设备。</p><p>没啥好折腾的，原版固件就很稳定，静静地当个带机量不大的小AP挺好的。</p><span id="more"></span><h2 id="原厂固件5G加入中国频段方法"><a href="#原厂固件5G加入中国频段方法" class="headerlink" title="原厂固件5G加入中国频段方法"></a>原厂固件5G加入中国频段方法</h2><ul><li>用户名<code>root</code></li><li>密码<code>plumeria0077</code></li></ul><p>打开<code>192.168.0.1/syscmd.asp</code></p><p>输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flash sethw HW_WLAN1_REG_DOMAIN 2</span><br><span class="line">flash sethw HW_WLAN0_REG_DOMAIN 2</span><br></pre></td></tr></table></figure><p>重启后进入设置，打开SSID3设置页面(确保5G必须打开)，接着进入<code>192.168.0.1/wlbasic.asp</code>选频段，默认是自动，可以设置149和153两个国内信道。<br>再次重启就可以了。</p><p><a href="http://www.right.com.cn/forum/thread-164531-1-1.html">原文地址</a></p><h2 id="1、关闭WPS"><a href="#1、关闭WPS" class="headerlink" title="1、关闭WPS"></a>1、关闭WPS</h2><p>2.4Ghz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash set WLAN0_WSC_DISABLE 1</span><br></pre></td></tr></table></figure><p>5Ghz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash set WLAN1_WSC_DISABLE 1</span><br></pre></td></tr></table></figure><p>害怕被PIN可以看一下这些文字：<br>If the wrong PIN code three times, You will not be able to connect more. Please press the button below to release it.<br>UnLock<br>我也曾mdk3攻击路由器，使它重启，但是攻击5分钟无效。</p><p>&#x3D;&#x3D;&#x3D;&#x3D; 2、使用中国5Ghz频道 &#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash set WLAN0_CHANNEL 149</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D; 3、更改时区为东八区 &#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash set NTP_TIMEZONE -8\ 1</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D; 4、更改LAN IP地址 &#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flash set IP_ADDR 192.168.0.1</span><br><span class="line">flash set SUBNET_MASK 255.255.255.0</span><br><span class="line">flash set DHCP_CLIENT_START 192.168.0.100</span><br><span class="line">flash set DHCP_CLIENT_END 192.168.0.200</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D; 5、更改用户名密码 &#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flash set SUPER_NAME root</span><br><span class="line">flash set SUPER_PASSWORD plumeria0077</span><br><span class="line">flash set USER_NAME au</span><br><span class="line">flash set USER_PASSWORD 1234</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D; 6、修改PIN码 ( 此项修改之后是初始化无法复原的 ) &#x3D;&#x3D;&#x3D;&#x3D;</p><p>2.4Ghz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash sethw HW_WLAN0_WSC_PIN xxxxxxxx</span><br></pre></td></tr></table></figure><p>5Ghz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash sethw HW_WLAN1_WSC_PIN xxxxxxxx</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; sdk固件要刷回原版，可以参考【N500R_TTL+TFTP写入教程】， &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>注意：</p><ol><li>加电时RESET， 然后192.168.1.6 就可以了，电脑地址要设为192.168.1.x。</li><li>tftp上传的原版固件威编程器固件，大小是8M的。8192kB3.</li></ol><p>刷机命令</p><p><code>FLW 0 80500000 800000</code></p><p>注意一定是大写的。<br>4. 启动后，登陆时账号是root，密码plumeria0077，你们的可以试试哈。</p><ol start="5"><li>关于5G 149信道设置：虽然设置为149，但在【本机状态】5G信道是36，解决方法：</li></ol><p>打开【系统维护】【系统命令行】或者192.168.0.1&#x2F;syscmd.asp<br>输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flash sethw HW_WLAN1_REG_DOMAIN 2</span><br><span class="line">flash sethw HW_WLAN0_REG_DOMAIN 2</span><br></pre></td></tr></table></figure><p>重启后进入设置，打开SSID3设置页面(确保5G必须打开)，接着进入【无线设置】或192.168.0.1&#x2F;wlbasic.asp选频段，默认是自动，<br>可以设置149和153两个国内信道。新版的信道可以输入。<br>再次重启就可以了。<br>可以在【本机状态】查看5G是否是149信道。</p><h1 id="恢复Ccalibration-Power"><a href="#恢复Ccalibration-Power" class="headerlink" title="恢复Ccalibration Power"></a>恢复Ccalibration Power</h1><p>赶紧查了一下，找到了[Embedded System] 手動設定 Ccalibration Power 搞定。</p><p>怎么样修改Ccalibration Power呢，举个栗子，说一下。<br>1、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HW_WLAN0_TX_POWER_CCK_A=3333333131313131313131313131</span><br></pre></td></tr></table></figure><p>33是16进制转换10进制为51，31转换为49。</p><p>命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash set HW_WLAN0_TX_POWER_CCK_A 51 51 51 49 49 49 49 49 49 49 49 49 49 49</span><br></pre></td></tr></table></figure><p>2、复杂一点的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HW_WLAN0_TX_POWER_5G_HT40_1S_A=00000000000000000000000000000000000000000000000000000000000000000000002f2f2f2f2f2f2f2f2f2f2d2d2d2d2d2d2d2d2d2d2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2c2c2c2c2c2c2d2d2d2d2d2d000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>你自己转换分组的，我累了。（末尾的00舍弃）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash sethw HW_WLAN0_TX_POWER_5G_HT40_1S_B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 47 47 47 47 47 47 47 47 47 47 45 45 45 45 45 45 45 45 45 45 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 44 44 44 44 44 44 45 45 45 45 45 45</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;au home spot cube 是个挺低配的小路由，可能是最便宜的带5G频段（802.11n，aka WIFI 4）的设备。&lt;/p&gt;
&lt;p&gt;没啥好折腾的，原版固件就很稳定，静静地当个带机量不大的小AP挺好的。&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="wifi" scheme="https://boypt.github.io/tags/wifi/"/>
    
    <category term="router" scheme="https://boypt.github.io/tags/router/"/>
    
    <category term="‎PXH11RWA" scheme="https://boypt.github.io/tags/%E2%80%8EPXH11RWA/"/>
    
  </entry>
  
  <entry>
    <title>移动/电信光猫超级密码</title>
    <link href="https://boypt.github.io/2021/09/07/fibermodem-psw/"/>
    <id>https://boypt.github.io/2021/09/07/fibermodem-psw/</id>
    <published>2021-09-07T02:30:37.000Z</published>
    <updated>2022-10-19T02:45:48.994Z</updated>
    
    <content type="html"><![CDATA[<p>移动电信光猫密码</p><span id="more"></span><h1 id="移动-烽火HG6821M"><a href="#移动-烽火HG6821M" class="headerlink" title="移动 烽火HG6821M"></a>移动 烽火HG6821M</h1><h2 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h2><ul><li>用户名：<code>CMCCAdmin</code></li><li>密码：<code>aDm8H%MdA</code></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>用户名：<code>fiberhomehg2x0</code></li><li>密码：<code>hg2x0</code></li></ul><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><ul><li>用户名：<code>root</code></li><li>密码：<code>hg2x0</code></li></ul><h1 id="电信-中兴-ZXHN-F650"><a href="#电信-中兴-ZXHN-F650" class="headerlink" title="电信 中兴 ZXHN F650"></a>电信 中兴 ZXHN F650</h1><h2 id="超级用户-1"><a href="#超级用户-1" class="headerlink" title="超级用户"></a>超级用户</h2><ul><li>用户名：<code>telecomadmin</code></li><li>密码：<code>nE7jA%5m</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;移动电信光猫密码&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="modem" scheme="https://boypt.github.io/tags/modem/"/>
    
    <category term="光猫" scheme="https://boypt.github.io/tags/%E5%85%89%E7%8C%AB/"/>
    
    <category term="HG6821M" scheme="https://boypt.github.io/tags/HG6821M/"/>
    
  </entry>
  
  <entry>
    <title>在路由器iptables中匹配IPv6动态地址</title>
    <link href="https://boypt.github.io/2018/10/24/match-ipv6/"/>
    <id>https://boypt.github.io/2018/10/24/match-ipv6/</id>
    <published>2018-10-24T07:59:18.000Z</published>
    <updated>2022-10-19T02:45:48.998Z</updated>
    
    <content type="html"><![CDATA[<p>家用宽带目前很多都部署了IPv6，家用路由器目前Padavan&#x2F;Openwrt等系统都能较好地支持了IPv6。不过要充分利用IPv6链接设备，有些坑。</p><span id="more"></span><h3 id="动态变化的IPv6地址"><a href="#动态变化的IPv6地址" class="headerlink" title="动态变化的IPv6地址"></a>动态变化的IPv6地址</h3><p>首先是IPv6地址，不同设备（操作系统）获取的IPv6地址有区别，较为通用的是【无状态EUI-64地址】，操作系统通过网卡的mac地址生成一个64位固定后缀，以及路由器下发的64位前缀，合成一个固定的IPv6地址。</p><p>作为服务端，【无状态EUI-64地址】是较为适合的，Linux发行版很多组件（systemd-netword，dhcpcd等）默认都采用EUI-64地址。 </p><p>另外还有通过DHCPv6下发的地址，可以通过设置静态分发，对应设备（DUID）下发特定地址。作为服务器地址最适合的方式。</p><p>此外，家用宽带ISP提供的IPv6前缀是不定期变化的。可见要访问家庭宽带内网的设备，光是地址就存在了蛮多的变化因素。</p><h3 id="IPv6的【隐私扩展地址】"><a href="#IPv6的【隐私扩展地址】" class="headerlink" title="IPv6的【隐私扩展地址】"></a>IPv6的【隐私扩展地址】</h3><p>终端设备，比如手机、工作站版本Windows等设备，则使用【隐私扩展】的方式随机生成64位后缀，这样终端的地址每次链接时候都会随机改变，访问外部资源时候可避免被追踪。 如果要连接Windows远程桌面，安装的是工作站版本，系统默认已经启用【隐私扩展】，主机地址就是随机变化的，想要连接3389就很麻烦了，不过这个特性可以关闭。服务器版本的Windows默认不启用隐私扩展，而家庭版Windows不支持远程桌面[doge]。 管理员权限的CMD下执行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 set global randomizeidentifiers=disabled store=active </span><br><span class="line">netsh interface ipv6 set global randomizeidentifiers=disabled store=persistent </span><br><span class="line">netsh interface ipv6 set privacy state=disabled store=active </span><br><span class="line">netsh interface ipv6 set privacy state=disabled store=persistent</span><br></pre></td></tr></table></figure><h3 id="IPv6防火墙ip6tables"><a href="#IPv6防火墙ip6tables" class="headerlink" title="IPv6防火墙ip6tables"></a>IPv6防火墙ip6tables</h3><p>要从外网通过IPv6访问家里路由器下的设备，最关键一点是路由器上的防火墙要允许这样的转发。 Padavan&#x2F;Openwrt都是基于Linux - ip6tables的防火墙。</p><p>默认情况下，只允许了v6子网内的设备被ping，只允许特定类型的ICMPv6报文通过转发，其他通信报文一律丢弃了。所以虽然IPv6下每个设备都有公网地址，但是还不至于不安全到每个设备都可让人随便连。</p><h3 id="动态匹配EUI-64后缀"><a href="#动态匹配EUI-64后缀" class="headerlink" title="动态匹配EUI-64后缀"></a>动态匹配EUI-64后缀</h3><p>考虑到前缀变化因素，要访问特定设备，就是让IPTABLES匹配特定设备的EUI-64后缀放通这个地址： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -I FORWARD -d ::abcd:1234:5678:90ef/::ffff:ffff:ffff:ffff -j ACCEPT</span><br></pre></td></tr></table></figure><p>可见iptables对v6地址的匹配<strong>掩码</strong>可以非常灵活，不像v4下只按前缀适配。坑的就是这个特征是没有文档的，目前文档中写的mask解释还是适配IPv4的内容，<a href="http://blog.dupondje.be/?p=17">有人专门发邮件去netfilter列表问了才知道</a>。IPv6地址中，双冒号::的写法代表是前&#x2F;后均为0位，双冒号只能出现一次。</p><h3 id="动态匹配DHCPv6固定后缀"><a href="#动态匹配DHCPv6固定后缀" class="headerlink" title="动态匹配DHCPv6固定后缀"></a>动态匹配DHCPv6固定后缀</h3><p>对于内网服务器，可以设置DHCPv6进行固定网段后缀分配，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">240e:1234:5678:1234::1024:101</span><br><span class="line">240e:1234:5678:1234::1024:102</span><br><span class="line">240e:1234:5678:1234::1024:103</span><br><span class="line">240e:1234:5678:1234::1024:104</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在路由器上可以一个命令匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -I FORWARD -d ::1024:0000/::ffff:0000 -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="Openwrt中配置转发规则"><a href="#Openwrt中配置转发规则" class="headerlink" title="Openwrt中配置转发规则"></a>Openwrt中配置转发规则</h3><p><img src="/2018/10/24/match-ipv6/openwrt-ip6tables.png"></p><h3 id="Padavan中设置转发规则"><a href="#Padavan中设置转发规则" class="headerlink" title="Padavan中设置转发规则"></a>Padavan中设置转发规则</h3><p>其实padavan中的防火墙功能并没有配置地址匹配转发规则的功能界面，只能在自定义脚本中写原始的iptables命令。截图中使用的padavan是增加了QOS组件的老毛子版本。   </p><p><img src="/2018/10/24/match-ipv6/padavan-ip6tables.png" alt="padavan-ip6tables"><br>以上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;家用宽带目前很多都部署了IPv6，家用路由器目前Padavan&amp;#x2F;Openwrt等系统都能较好地支持了IPv6。不过要充分利用IPv6链接设备，有些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="iptables" scheme="https://boypt.github.io/tags/iptables/"/>
    
    <category term="address" scheme="https://boypt.github.io/tags/address/"/>
    
    <category term="ipv6" scheme="https://boypt.github.io/tags/ipv6/"/>
    
    <category term="suffix" scheme="https://boypt.github.io/tags/suffix/"/>
    
  </entry>
  
  <entry>
    <title>iptables笔记</title>
    <link href="https://boypt.github.io/2018/09/07/iptables/"/>
    <id>https://boypt.github.io/2018/09/07/iptables/</id>
    <published>2018-09-07T02:39:44.000Z</published>
    <updated>2022-10-19T02:45:48.994Z</updated>
    
    <content type="html"><![CDATA[<p>iptables笔记</p><span id="more"></span><h1 id="Packet-Flow-Chart"><a href="#Packet-Flow-Chart" class="headerlink" title="Packet Flow Chart"></a>Packet Flow Chart</h1><p><img src="/2018/09/07/iptables/packet_flow10.png"></p><h1 id="Netfilter-Flow-Chart"><a href="#Netfilter-Flow-Chart" class="headerlink" title="Netfilter Flow Chart"></a>Netfilter Flow Chart</h1><p><img src="/2018/09/07/iptables/Netfilter-packet-flow.svg.png"></p><h1 id="Firewall-Rules"><a href="#Firewall-Rules" class="headerlink" title="Firewall Rules"></a>Firewall Rules</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install iptables-persistent</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NAT-as-port-forwarding"><a href="#NAT-as-port-forwarding" class="headerlink" title="NAT as port forwarding"></a>NAT as port forwarding</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 数据包进入PREROUTING Chain，DNAT修改来源数据包的目的地址/端口为映射的$DEST_IP:$PORT</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dst $WAN_IP --dport 80 -j DNAT --to-destination $DEST_IP:$PORT</span><br><span class="line"></span><br><span class="line"># 此时Packet的目的地址不是本机地址，而是$DEST_IP，进入filter表的FORWARD Chain进行规则审核，要允许其通过（若filter表已是默认允许的，可以忽略本条）</span><br><span class="line">iptables -A FORWARD -p tcp --dst $DEST_IP --dport $PORT -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 进入POSTROUTING Chain，SNAT修改数据包中的来源地址为本网关；若目的机的默认网关就是本机，可以忽略本步（因为如果是目的机的默认网关，不管发往哪里的包都是发回来本网关；不然的话会发去了另外一个网关，无法成为相同一个NAT会话，无法通信）。默认网关的方式不用这句时目标机可以看到来源的真实地址。</span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp --dst $DEST_IP --dport 80 -j SNAT --to-source $LAN_IP</span><br><span class="line"></span><br><span class="line"># 在网关本机和内网其他机器访问WAN_IP这个端口映射，数据包产生在OUTPUT Chain，需要做和PREROUTING相同的操作才能访问到（若不需要，可忽略本步）</span><br><span class="line">iptables -t nat -A POSTROUTING --dst $WAN_IP -p tcp --dport 80 -j DNAT --to-destination $DEST_IP:$PORT</span><br></pre></td></tr></table></figure><h1 id="NAT-as-gateway"><a href="#NAT-as-gateway" class="headerlink" title="NAT as gateway"></a>NAT as gateway</h1><p>Enable IP Forwarding</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/.*net\.ipv4\.ip_forward.*/net.ipv4.ip_forward = 1/&#x27; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>MASQUERADE, pppoe等动态IP环境使用环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>or</p><p>SNAT, 静态外网IP, 或出口网卡绑定了多个IP时候使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j SNAT --to-source &lt;IP&gt;</span><br></pre></td></tr></table></figure><p>自动调整经pppoe-wan接口发出的TCP数据MSS, PPP链路情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -I POSTROUTING -o pppoe-wan -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</span><br></pre></td></tr></table></figure><h1 id="NAT-as-proxy-（双向NAT，举例推特API服务器hosts转发）"><a href="#NAT-as-proxy-（双向NAT，举例推特API服务器hosts转发）" class="headerlink" title="NAT as proxy （双向NAT，举例推特API服务器hosts转发）"></a>NAT as proxy （双向NAT，举例推特API服务器hosts转发）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d [YOUR SERVER IP] -p tcp -m tcp --dport 443 -j DNAT --to-destination 199.59.148.20:443 </span><br><span class="line">iptables -t nat -A POSTROUTING -d 199.59.148.20 -p tcp -m tcp --dport 443 -j SNAT --to-source [YOUR SERVER IP]</span><br><span class="line"></span><br><span class="line">iptables -A FORWARD -d 199.59.148.20 -p tcp -m tcp --dport 443 -j ACCEPT </span><br><span class="line">iptables -A FORWARD -s 199.59.148.20 -p tcp -m tcp --sport 443 -m state --state RELATED,ESTABLISHED -j ACCEPT </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Iptables-Firewall-后-FTP-服务-List-命令超时"><a href="#Iptables-Firewall-后-FTP-服务-List-命令超时" class="headerlink" title="Iptables Firewall 后 FTP 服务 List 命令超时"></a>Iptables Firewall 后 FTP 服务 List 命令超时</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe ip_conntrack_ftp</span><br><span class="line">echo &quot;ip_conntrack_ftp&quot; &gt;&gt;/etc/modules</span><br></pre></td></tr></table></figure><h1 id="Filter-DNS-from-GFW"><a href="#Filter-DNS-from-GFW" class="headerlink" title="Filter DNS from GFW"></a>Filter DNS from GFW</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT --source 8.8.8.8,8.8.4.4 -p udp --source-port 53 -m dscp ! --dscp 0x00 -j DROP</span><br><span class="line">iptables -A INPUT --source 8.8.8.8,8.8.4.4 -p udp --source-port 53 -m ttl --ttl-gt 48 -j DROP </span><br></pre></td></tr></table></figure><h1 id="Quick-fix-for-deprecated-state-module-since-Dec-2012"><a href="#Quick-fix-for-deprecated-state-module-since-Dec-2012" class="headerlink" title="Quick fix for deprecated state module [since Dec 2012]"></a>Quick fix for deprecated state module [since Dec 2012]</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/-m state --state/-m conntrack --ctstate/g&quot; /etc/iptables/iptables.rules</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;iptables笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Networking" scheme="https://boypt.github.io/categories/Networking/"/>
    
    
    <category term="iptables" scheme="https://boypt.github.io/tags/iptables/"/>
    
    <category term="linux" scheme="https://boypt.github.io/tags/linux/"/>
    
  </entry>
  
</feed>

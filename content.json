{"meta":{"title":"无证程序员的PT桑","subtitle":"删库跑路中 ╮(╯▽╰)╭","description":"","author":"PTさん","url":"https://boypt.github.io","root":"/"},"pages":[{"title":"About","date":"2021-10-22T06:20:27.425Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"about/index.html","permalink":"https://boypt.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2021-10-22T06:20:27.425Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"project/index.html","permalink":"https://boypt.github.io/project/index.html","excerpt":"","text":""},{"title":"Series","date":"2021-10-22T06:20:27.425Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"series/index.html","permalink":"https://boypt.github.io/series/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-10-22T06:20:27.425Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"tags/index.html","permalink":"https://boypt.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"树莓派使用硬件RTC时钟","slug":"raspberry-rtc","date":"2021-10-22T05:19:03.000Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"2021/10/22/raspberry-rtc/","link":"","permalink":"https://boypt.github.io/2021/10/22/raspberry-rtc/","excerpt":"树莓派等各种派，往往都不带硬件时钟，在断电、离线网络等情况下是无法以实际时间运行系统和程序的。解决方式是安装一个RTC时钟模块，成本也不高，但是软硬件各方面可能有一些坑要踩一下。","text":"树莓派等各种派，往往都不带硬件时钟，在断电、离线网络等情况下是无法以实际时间运行系统和程序的。解决方式是安装一个RTC时钟模块，成本也不高，但是软硬件各方面可能有一些坑要踩一下。 硬件模块硬件上可以选择上图这种专门为raspberry 40pin 接口使用的小模块，成本较高（淘宝售价10元+），但是组装性能好一些，跟主板本身能紧密连接。性能方面，ds1307其实只是个计数芯片，实际走时是通过外部32768Hz的晶振，精度可能不会十分准确。另外这个模块扣具一下子占了10个pin口，其中包括模块通信使用的i2c、电源5v/3.3v，以及常用调试的uart ttl口，不过也引出了插针，调试倒不成问题。 有性能更好的ds3231模块，芯片内部自带晶振，受干扰和晶振质量影响较小，走时较为准确，不过成本高一些。 如果使用更通用的模块，ds1307甚至有卖2块钱的小模块，只是需要另外连接引线。其实这小小模块的性能考虑还挺多的，比如有些模块提供电池充电等等。 软件配置上述这些RTC模块其实使用了i2c通信接口，而树莓派对应的系统基本都要对应的内核模块支持，要驱动起来不算麻烦。 比如在raspberry 4B，只需要配置/boot/config.txt (具体文档在/boot/overlays/README)： 12dtoverlay=i2c-rtc,ds1307 dtparam=i2c=on 具体不通型号稍有区别，可以看51pi。 但是根据使用系统的不通，发现并不好用，虽然驱动加上了，系统时间并没有从硬件同步进来（也许是centos系列系统的问题？包括树莓自己的Raspberry Pi OS）。 查到一个方法是写自己的systemd服务，脚本控制模块加载和同步时间。 addon-hwclock.service 对应的脚本和service如下： 脚本 /etc/addon-hwclock 12345678910111213141516171819202122232425262728#!/bin/bash# Use add-on hardware RTC module. See /etc/systemd/system/addon-hwclock.service.# Be verbose so failures can be examined with `journalctl --unit addon-hwclock`.set -o errexitset -o xtraceif [[ &quot;$1&quot; = &quot;start&quot; ]]; then # Load the kernel modules needed by the RTC. # udevd might do some/all of this later, but we want it now (before root fsck). for i in i2c_bcm2835 rtc_ds1307; do /sbin/modprobe $i; done # Potentially useful debugging commands. Uncomment to taste. # /usr/bin/dtc --in-format fs /proc/device-tree # /usr/sbin/i2cdetect -y 1 # echo ds3231 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device echo ds1307 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device # Debugging, again. # /usr/bin/dtc --in-format fs /proc/device-tree # /usr/sbin/i2cdetect -y 1 /sbin/hwclock --hctosys --utcelif [[ &quot;$1&quot; = &quot;stop&quot; ]]; then /sbin/hwclock --systohc --utcfi Service /etc/systemd/system/addon-hwclock.service 123456789101112131415161718192021222324252627[Unit]Description=Add-on hardware RTC moduleDefaultDependencies=no# Run after fake-hwclock so it doesn&#x27;t override the time set from the real hwclock.After=fake-hwclock.service# Filesystems record their last mount time; fsck complains if it&#x27;s in the future.# Run before the first fsck to avoid this. Earlier in the boot process is better anyway.Before=sysinit.target systemd-fsck-root.service time-set.targetConflicts=shutdown.target# Note because of the WantedBy=sysinit.target, the system will boot into# emergency mode on failure. Be a little defensive with the ConditionFileIsExecutable# to avoid that annoying failure mode.ConditionFileIsExecutable=/etc/addon-hwclock[Service]Type=oneshotRemainAfterExit=yesExecStart=/etc/addon-hwclock startExecStop=/etc/addon-hwclock stop[Install]WantedBy=sysinit.target 然后激活使用，把当前时间写入到模块（–systohc） 1234567sudo chmod a+rx /etc/addon-hwclocksudo systemctl enable addon-hwclock.servicesh -c &#x27;for i in i2c_bcm2835 rtc_ds1307; do /sbin/modprobe $i; done&#x27;sh -c &#x27;echo ds1307 0x68 &gt; /sys/class/i2c-adapter/i2c-1/new_device&#x27;/sbin/hwclock --systohc --utc 然后就可以重启检查效果了。 跳坑电源稳定性发现虽然这么个小模块，也是对电源有要求的，使用主机USB、1A小电源启动树莓派后，会间歇性找不到RTC模块，或者各种其他报错。 换成5V 2A的电源就稳定了。折腾了不少时间。 调试i2c是个总线接口，可以连接很多设备，分别使用不同的地址进行通信。 使用i2cdetect -y 1可以扫描检测所有i2c设备。 比如ds1307模块使用的地址是0x68，上述扫描时候如果发现对应地址有设备就会显示对应的数字。 但是如果已经加载好驱动模块，对应地址就显示UU。 关于fake-hwclock服务fake-hwclock其实是树莓派系统默认对于不存在硬件时钟时候，把关机时候的时间写入到文件，开机时候重新读取，而不是从1970年开始重新算的时间。 不少资料说使用rtc模块后应该删除这个服务，其实不必须的，不影响上述模块的工作流程。还能避免在临时断开模块时候设备启动的时间又从1970开始的问题。 硬件连线使用硬件连线模块时候，注意是ds1307用的是5v，DS3231 和 PCF8523是用3.3v的。 DS3231 和 PCF8523 使用3.3v供电。** Vin 连接至 Pin 1 **** SDA 连接到 Pin 3 **** SCL 连接到 Pin 5 **** GND 连接到引脚 6 ** DS1307 使用5v供电。 ** Vin 连接至 Pin 4 **** SDA 连接到 Pin 3 **** SCL 连接到 Pin 5 **** GND 连接到引脚 6 **","categories":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/tags/linux/"},{"name":"raspberry","slug":"raspberry","permalink":"https://boypt.github.io/tags/raspberry/"}]},{"title":"用Nginx作为Webdav服务器","slug":"nginx-as-webdav","date":"2021-09-30T08:26:23.000Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"2021/09/30/nginx-as-webdav/","link":"","permalink":"https://boypt.github.io/2021/09/30/nginx-as-webdav/","excerpt":"提供Webdav服务，本来有rclone 、 go-webdav等使用golang的服务端，跑起来是非常方便的，但是如果设备是CPU性能较低内存较小的比如MTK7621，就分分钟卡死整个系统。 研究后决定用nginx提供webdav。","text":"提供Webdav服务，本来有rclone 、 go-webdav等使用golang的服务端，跑起来是非常方便的，但是如果设备是CPU性能较低内存较小的比如MTK7621，就分分钟卡死整个系统。 研究后决定用nginx提供webdav。 Nginx的Webdav支持是比较分裂的，一个是官方自带的ngx_http_dav_module但是功能不齐全，需要一个第三方模块nginx-dav-ext-module。不过在Openwrt里面直接opkg install nginx-all-module，是全带了适合的模块的了。 经测试，nginx提供的webdav访问响应明显好于rclone提供的。大概是MIPS价格下，golang的效率还是受限了。 直接上配置。 1234567891011121314151617181920212223242526272829303132333435363738dav_ext_lock_zone zone=davlock:10m;server &#123; listen 8081 default_server; listen [::]:8081 default_server; listen 8083 default_server ssl; listen [::]:8083 default_server ssl; ssl_certificate /etc/ssl/my.domain/fullchain.cer; ssl_certificate_key /etc/ssl/my.domain/my.domain.key; ssl_protocols TLSv1.3 TLSv1.2; ssl_ciphers EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA512:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:ECDH+AESGCM:ECDH+AES256:DH+AESGCM:DH+AES256:RSA+AESGCM:!aNULL:!eNULL:!LOW:!RC4:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS; ssl_session_cache shared:TLS:2m; ssl_buffer_size 4k; ssl_prefer_server_ciphers on; root /mnt; location / &#123; # enable creating directories without trailing slash set $x $uri$request_method; if ($x ~ [^/]MKCOL$) &#123; rewrite ^(.*)$ $1/; &#125; client_body_temp_path /mnt/sda1/.nginxtemp 2; autoindex on; dav_methods PUT DELETE MKCOL COPY MOVE; dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK; dav_ext_lock zone=davlock; dav_access user:rw group:rw all:rw; create_full_put_path on; client_max_body_size 0M; auth_basic &quot;Authorized Users Only&quot;; auth_basic_user_file /etc/nginx/webdavpasswd; satisfy any; &#125;&#125; 配置里面8081端口提供了http、8083提供了tls的https。 需要注意client_body_temp_path的参数，在webdav上传适合nginx会把临时文件先放到这个路径，然后才转移到实际上传路径。最好放在相同分区的目录下。 auth_basic_user_file是普通的http auth格式。 因为开启了autoindex on;，即使不用webdav客户端，直接浏览器访问也是能够下载对应目录和文件的。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/tags/linux/"},{"name":"networking","slug":"networking","permalink":"https://boypt.github.io/tags/networking/"},{"name":"webdav","slug":"webdav","permalink":"https://boypt.github.io/tags/webdav/"}]},{"title":"OpenVPN 客户端间选择性互通","slug":"openvpn-client2client-limit","date":"2021-09-28T06:33:08.000Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"2021/09/28/openvpn-client2client-limit/","link":"","permalink":"https://boypt.github.io/2021/09/28/openvpn-client2client-limit/","excerpt":"OpenVPN服务器中若配置了client-to-client, 终端之间是无限制互通的。","text":"OpenVPN服务器中若配置了client-to-client, 终端之间是无限制互通的。 配置文档中如此描述： 1234567# Uncomment this directive to allow different# clients to be able to &quot;see&quot; each other.# By default, clients will only see the server.# To force clients to only see the server, you# will also need to appropriately firewall the# server&#x27;s TUN/TAP interface.; client-to-client 如果想要指定特定终端能互通，特定不能通，不能打开这个选项。 首先要开启配置topology subnet。 此时服务器的tun0上是可以看到终端所有数据包了，即终端数据会进入服务器的内核IP Stack。 12345cat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOF# for openvpn client packet forwardnet.ipv4.ip_forward = 1EOFsysctl -p /etc/sysctl.conf 最后通过iptables的FORWARD规则，屏蔽特定不允许互通的网段。即可实现。 1iptables -A FORWARD -i tun0 -o tun0 -s 10.15.100.0/24 -d 10.15.100.0/24 -j DROP 原理摘自Stackoverflow一篇帖子，摘抄如下。 If client-to-client is enabled, the VPN server forwards client-to-client packets internally without sending them to the IP layer of the host (i.e. to the kernel). The host networking stack does not see those packets at all. 12345678910111213141516171819 .-------------------. | IP Layer | &#x27;-------------------&#x27; .-------------------. | TUN device (tun0) | &#x27;-------------------&#x27; .-------------------. | OpenVPN server | &#x27;-------------------&#x27; ^ | 1 | | 2 | v.----------------. .----------------.| Client a | | Client b |&#x27;----------------&#x27; &#x27;----------------&#x27; If client-to-client is disabled, the packets from a client to another client go through the host IP layer (iptables, routing table, etc.) of the machine hosting the VPN server: if IP forwarding is enabled, the host might forward the packet (using its routing table) again to the TUN interface and the VPN daemon will forward the packet to the correct client inside the tunnel. 123456789101112131415161718192021 .-------------------. | IP Layer | (4) routing, firewall, NAT, etc. &#x27;-------------------&#x27; (iptables, nftables, conntrack, tc, etc.) ^ | 3 | | 5 | v .-------------------. | TUN device (tun0) | &#x27;-------------------&#x27; ^ | 2 | | 6 | v .-------------------. | OpenVPN server | &#x27;-------------------&#x27; ^ | 1 | | 7 | v.----------------. .----------------.| Client a | | Client b |&#x27;----------------&#x27; &#x27;----------------&#x27; In this case (client-to-client disabled), you can block the client-to-client packets using iptables: 1iptables -A FORWARD -i tun0 -o tun0 -j DROP where tun0 is your VPN interface.","categories":[{"name":"networking","slug":"networking","permalink":"https://boypt.github.io/categories/networking/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/tags/linux/"},{"name":"networking","slug":"networking","permalink":"https://boypt.github.io/tags/networking/"},{"name":"openvpn","slug":"openvpn","permalink":"https://boypt.github.io/tags/openvpn/"}]},{"title":"使用Docker的Openwrt SDK编译环境","slug":"openwrtsdk","date":"2021-09-09T05:41:11.000Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"2021/09/09/openwrtsdk/","link":"","permalink":"https://boypt.github.io/2021/09/09/openwrtsdk/","excerpt":"Openwrt的编译环境算是比较易用的，只要下载对应设备的sdk包，解压就能使用。 不过一些基础程序包还是依赖原生系统，如果原系统的版本出现冲突，又会有麻烦。不过openwrt官方维护的各种架构和型号的docker镜像，基本都是特定版本的debian，统一化了环境，这就方便了许多。","text":"Openwrt的编译环境算是比较易用的，只要下载对应设备的sdk包，解压就能使用。 不过一些基础程序包还是依赖原生系统，如果原系统的版本出现冲突，又会有麻烦。不过openwrt官方维护的各种架构和型号的docker镜像，基本都是特定版本的debian，统一化了环境，这就方便了许多。 例子： 给openwrt 21.02编译一个aria2 1.36openwrt 21.02 版本时候，aria2 才1.35，所以正式版仓库里面不会有1.36，可以自己编一个。 1234567891011121314151617181920212223242526272829303132333435363738394041# 拖回一个镜像，这里以一个mtk 7621设备为例子docker pull openwrtorg/sdk:mipsel_24kc-openwrt-21.02# 开一个临时镜像一用，在里面编译完就不要了，所以用上了--rm，# 里面的终端做任何事情只要退了就一切消失docker run -it --rm openwrtorg/sdk:mipsel_24kc-openwrt-21.02 /bin/bash# 里面是个debian10的普通用户，但是vim什么的都没有，随便搞一下sudo sed -i &#x27;s|deb.debian.org|mirrors.aliyun.com|;s|security.debian.org|mirrors.aliyun.com|&#x27; /etc/apt/sources.listsudo apt update # lrzsz是为了方便跟本地传文件，不然编译完要回去用docker copy命令拷贝多麻烦，# sz 一下就能把容器里面的文件发到终端了sudo apt install vim-tiny lrzsz#普通用户的根目录就是openwrt的编译目录cp feeds.conf.default feeds.confvim feeds.conf# 复制一份配置, 因为aria2只在packages仓库，因此只保留一行# src-git packages https://git.openwrt.org/feed/packages.git^65057dcbb5de371503c9159de3d45824bec482e0# 又因为后面的^65057...是21.02版本的id，我需要最新版的，去掉。# 就变成 src-git packages https://git.openwrt.org/feed/packages.git# 从这里开始是需要联网操作的，如果环境在墙内需要设置代理，随便指定个http代理的就好export http_proxy=http://192.168.0.99:3128./scripts/feeds update packages# feeds 命令是同步仓库里面的包源码到本地./scripts/feeds install aria2# 因为aria2 1.36已经在仓库里面了，不需要改源码# 如果仓库没及时更新，可以修改package/feeds/packages/aria2/Makefile# 直接开片make package/aria2/compile# 期间会出现menuconfig，需要找到选择编译模块等等的# 完成后直接在bin目录里面找到对应的ipk，以及对应的依赖# 打包后sz出来发到设备里面安装即可","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://boypt.github.io/tags/openwrt/"},{"name":"docker","slug":"docker","permalink":"https://boypt.github.io/tags/docker/"},{"name":"sdk","slug":"sdk","permalink":"https://boypt.github.io/tags/sdk/"}]},{"title":"无线网卡AR5B22的5G频段","slug":"ar5b22","date":"2021-09-07T06:30:04.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2021/09/07/ar5b22/","link":"","permalink":"https://boypt.github.io/2021/09/07/ar5b22/","excerpt":"AR5B22的无线芯片是AR9462。AR5B22在win7时代算是个挺热门的“神卡”，因为能用Killer的驱动颇有名气。但是作为早已停产的芯片和产品，这网卡在Win10下已经有点跟不上。","text":"AR5B22的无线芯片是AR9462。AR5B22在win7时代算是个挺热门的“神卡”，因为能用Killer的驱动颇有名气。但是作为早已停产的芯片和产品，这网卡在Win10下已经有点跟不上。 主要体现在Wifi 5G频段上，因为当时中国的5G频段还是只有149~161频，所以这个网卡也只能搜到这几个频段的。倒不是他连不上，完全是因为老旧的驱动代码限制了。 多次摸索后，需要手动选择另外的驱动，才能解除。 安装高通驱动首先下载安装高通的驱动大补包 ath-drivers.eu Qualcomm Atheros wireless driver 10.0.3.456 for AR9462 and Windows 10 安装后手动更改设备的驱动，手动选择11a|b|g|n Wireless Lan Mini-PCI Express Adapter，系统提示不兼容也要强上。 如图所示，实测这两个型号驱动都能使用。","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"wifi","slug":"wifi","permalink":"https://boypt.github.io/tags/wifi/"},{"name":"wireless","slug":"wireless","permalink":"https://boypt.github.io/tags/wireless/"},{"name":"ar5b22","slug":"ar5b22","permalink":"https://boypt.github.io/tags/ar5b22/"}]},{"title":"大麦DW33D刷机总结帖","slug":"dw33d","date":"2021-09-07T05:44:04.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2021/09/07/dw33d/","link":"","permalink":"https://boypt.github.io/2021/09/07/dw33d/","excerpt":"大麦DW33D已经是很多年前的路由，都2021了可能配置上的有点过时（1750MAC Wifi+全千兆+高通QCA9558），但是如果本着性价比出发的话，目前某鱼上不到50一台的性价比确实还行的。","text":"大麦DW33D已经是很多年前的路由，都2021了可能配置上的有点过时（1750MAC Wifi+全千兆+高通QCA9558），但是如果本着性价比出发的话，目前某鱼上不到50一台的性价比确实还行的。 总结一下刷机要点。 背景dw33d内部有三个存储空间（可理解为硬盘），SPI-NOR(16M)、 NAND(128M)、 TF卡（16G）。 原厂固件是在NOR上的，一些旧版（lede 17.x）也是设计刷到NOR上，这类固件称为(ath1x)。BREED默认也是刷到NOR，启动也是NOR。 后来openwrt把dw33d纳入官方支持时候，改成使用NAND作为固件区域，并称为ath79，或者nand固件。 旧版固件虽然刷入简单（可以Breed WEB页面直刷），但是可用空间非常有限。 nand固件的刷入较为复杂，但是有足够大的存储空间（可用空间70M+），可以安装很多可选插件。 Breed虽然在dw33d上工作不完美，但是还是比u-boot简化一丢丢。 刷机方法可以是u-boot，连接TTL线操作；也可以不拆外壳，telnet操作； 简洁刷机Breed刷Nand看起来很复杂，其实总共3个步骤： Breed设置环境变量 PC开启http服务器 Breed Telnet下载并写入固件。 设置环境变量目的是让breed默认从nand开始启动，bank 0是nand空间。 12345678envconf 0x6000000 0x20000env set network.ipaddr 192.168.1.1env set network.netmask 255.255.255.0env set autoboot.disabled 0env set autoboot.delay 5env set autoboot.command &quot;boot flash bank 0 0x0&quot;env save PC上开启HTTP服务器确保dw33d的地址能访问到pc, 例子中pc的地址是192.168.0.254 Breed 下载固件此处原理是，breed命令的wget下载指定地址的文件，放到地址0x80000000。然后需要注意提示下载的长度(0xd00000) 然后擦除对应长度的nand空间，然后从0x80000000复制写入特定长度的数据 12345wget http://192.168.0.254/firmware/dw33d-factory.bin##### 注意长度的0xd00000#####-&gt; Length: 13631488/0xd00000 (13MB) [application/octet-stream]flash bank 0 erase 0x0 0xd00000flash bank 0 write 0x0 0x80000000 0xd00000 关于升级测试过从21.02-rc升级到21.02正式版，直接web升级没出现问题。 但是软件包需要重装，常用工具curl/tcpdump之类。","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"wifi","slug":"wifi","permalink":"https://boypt.github.io/tags/wifi/"},{"name":"rouer","slug":"rouer","permalink":"https://boypt.github.io/tags/rouer/"},{"name":"dw33d","slug":"dw33d","permalink":"https://boypt.github.io/tags/dw33d/"}]},{"title":"迅雷下载宝OPENWRT官方版本折腾SD卡扩容","slug":"thundercloud","date":"2021-09-07T05:32:54.000Z","updated":"2021-10-22T06:20:27.425Z","comments":true,"path":"2021/09/07/thundercloud/","link":"","permalink":"https://boypt.github.io/2021/09/07/thundercloud/","excerpt":"迅雷下载宝使用OPENWRT 21.02正式版","text":"迅雷下载宝使用OPENWRT 21.02正式版 Breed下直接刷入本来直接可用，没有太多需要折腾的。但是空间不大，而下载宝有个SD卡槽，可以折腾ExtRoot扩容。 官方文档 一些关键步骤替换源、安装必要内核模块 我把sd卡分区后格式化成f2fs了，官方里面推荐ext4 1234567sed -i &#x27;s|downloads.openwrt.org|mirrors.aliyun.com/openwrt|&#x27; /etc/opkg/distfeeds.confsed -i &#x27;s|downloads.openwrt.org|mirrors.tencent.com/openwrt|&#x27; /etc/opkg/distfeeds.confopkg updateopkg install block-mount kmod-fs-f2fs kmod-fs-ext4 kmod-usb-storage kmod-usb-ohci kmod-usb-uhci fdisk kmod-sdhci-mt7620 f2fs-tools f2fsck mkf2fs 以下才是关键步骤 1234567891011121314151617181920212223block info# 查到具体分区的uuid， 对应替换uci -q delete fstab.rwmuci set fstab.rwm=&quot;mount&quot;uci set fstab.rwm.device=&quot;/dev/mtdblock6&quot;uci set fstab.rwm.target=&quot;/rwm&quot;uci commit fstabuci -q delete fstab.overlayuci set fstab.overlay=&quot;mount&quot;uci set fstab.overlay.uuid=&quot;010624d4-e8a2-432c-8fde-b23cf18ebe20&quot;uci set fstab.overlay.target=&quot;/overlay&quot;uci commit fstab#迁移数据mkdir -p /tmp/cprootmount --bind /overlay /tmp/cprootmount /dev/mmcblk0p1 /mnttar -C /tmp/cproot -cvf - . | tar -C /mnt -xf - umount /tmp/cproot /mntreboot 关于升级升级后这些配置都没了，都得重新搞。sd卡的分区没必要格式化重来，但是以上步骤的数据迁移还是要做，升级后overlay的文件会有更新。内核/lib/modules对应版本的目录可以删除。 最重要一点，要删掉.extroot-uuid 1234mount /dev/sda1 /mntrm -f /mnt/.extroot-uuid /mnt/etc/.extroot-uuidumount /mnt 见官方文档的Troubleshooting block: extroot: UUID mismatch","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://boypt.github.io/tags/openwrt/"},{"name":"xunlei","slug":"xunlei","permalink":"https://boypt.github.io/tags/xunlei/"}]},{"title":"日本 au home spot cube 水晶盒子Wifi路由","slug":"auhome-spot-cube","date":"2021-09-07T02:34:27.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2021/09/07/auhome-spot-cube/","link":"","permalink":"https://boypt.github.io/2021/09/07/auhome-spot-cube/","excerpt":"au home spot cube 是个挺低配的小路由，可能是最便宜的带5G频段（802.11n，aka WIFI 4）的设备。 没啥好折腾的，原版固件就很稳定，静静地当个带机量不大的小AP挺好的。","text":"au home spot cube 是个挺低配的小路由，可能是最便宜的带5G频段（802.11n，aka WIFI 4）的设备。 没啥好折腾的，原版固件就很稳定，静静地当个带机量不大的小AP挺好的。 原厂固件5G加入中国频段方法 用户名root 密码plumeria0077 打开192.168.0.1/syscmd.asp 输入命令： 12flash sethw HW_WLAN1_REG_DOMAIN 2flash sethw HW_WLAN0_REG_DOMAIN 2 重启后进入设置，打开SSID3设置页面(确保5G必须打开)，接着进入192.168.0.1/wlbasic.asp选频段，默认是自动，可以设置149和153两个国内信道。再次重启就可以了。 原文地址 1、关闭WPS2.4Ghz 1flash set WLAN0_WSC_DISABLE 1 5Ghz 1flash set WLAN1_WSC_DISABLE 1 害怕被PIN可以看一下这些文字：If the wrong PIN code three times, You will not be able to connect more. Please press the button below to release it.UnLock我也曾mdk3攻击路由器，使它重启，但是攻击5分钟无效。 ==== 2、使用中国5Ghz频道 ==== 1flash set WLAN0_CHANNEL 149 ==== 3、更改时区为东八区 ==== 1flash set NTP_TIMEZONE -8\\ 1 ==== 4、更改LAN IP地址 ==== 1234flash set IP_ADDR 192.168.0.1flash set SUBNET_MASK 255.255.255.0flash set DHCP_CLIENT_START 192.168.0.100flash set DHCP_CLIENT_END 192.168.0.200 ==== 5、更改用户名密码 ==== 1234flash set SUPER_NAME rootflash set SUPER_PASSWORD plumeria0077flash set USER_NAME auflash set USER_PASSWORD 1234 ==== 6、修改PIN码 ( 此项修改之后是初始化无法复原的 ) ==== 2.4Ghz 1flash sethw HW_WLAN0_WSC_PIN xxxxxxxx 5Ghz 1flash sethw HW_WLAN1_WSC_PIN xxxxxxxx ===== sdk固件要刷回原版，可以参考【N500R_TTL+TFTP写入教程】， ===== 注意： 加电时RESET， 然后192.168.1.6 就可以了，电脑地址要设为192.168.1.x。 tftp上传的原版固件威编程器固件，大小是8M的。8192kB3. 刷机命令 FLW 0 80500000 800000 注意一定是大写的。4. 启动后，登陆时账号是root，密码plumeria0077，你们的可以试试哈。 关于5G 149信道设置：虽然设置为149，但在【本机状态】5G信道是36，解决方法： 打开【系统维护】【系统命令行】或者192.168.0.1/syscmd.asp输入命令： 12flash sethw HW_WLAN1_REG_DOMAIN 2flash sethw HW_WLAN0_REG_DOMAIN 2 重启后进入设置，打开SSID3设置页面(确保5G必须打开)，接着进入【无线设置】或192.168.0.1/wlbasic.asp选频段，默认是自动，可以设置149和153两个国内信道。新版的信道可以输入。再次重启就可以了。可以在【本机状态】查看5G是否是149信道。 恢复Ccalibration Power赶紧查了一下，找到了[Embedded System] 手動設定 Ccalibration Power 搞定。 怎么样修改Ccalibration Power呢，举个栗子，说一下。1、 1HW_WLAN0_TX_POWER_CCK_A=3333333131313131313131313131 33是16进制转换10进制为51，31转换为49。 命令是： 1flash set HW_WLAN0_TX_POWER_CCK_A 51 51 51 49 49 49 49 49 49 49 49 49 49 49 2、复杂一点的： 1HW_WLAN0_TX_POWER_5G_HT40_1S_A=00000000000000000000000000000000000000000000000000000000000000000000002f2f2f2f2f2f2f2f2f2f2d2d2d2d2d2d2d2d2d2d2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2c2c2c2c2c2c2d2d2d2d2d2d000000000000000000000000000000000000000000000000000000000000 你自己转换分组的，我累了。（末尾的00舍弃） 1flash sethw HW_WLAN0_TX_POWER_5G_HT40_1S_B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 47 47 47 47 47 47 47 47 47 47 45 45 45 45 45 45 45 45 45 45 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 44 44 44 44 44 44 45 45 45 45 45 45","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"wifi","slug":"wifi","permalink":"https://boypt.github.io/tags/wifi/"},{"name":"router","slug":"router","permalink":"https://boypt.github.io/tags/router/"},{"name":"‎PXH11RWA","slug":"‎PXH11RWA","permalink":"https://boypt.github.io/tags/%E2%80%8EPXH11RWA/"}]},{"title":"移动/电信光猫超级密码","slug":"fibermodem-psw","date":"2021-09-07T02:30:37.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2021/09/07/fibermodem-psw/","link":"","permalink":"https://boypt.github.io/2021/09/07/fibermodem-psw/","excerpt":"移动电信光猫密码","text":"移动电信光猫密码 移动 烽火HG6821M超级用户 用户名：CMCCAdmin 密码：aDm8H%MdA 工厂模式 用户名：fiberhomehg2x0 密码：hg2x0 telnet 用户名：root 密码：hg2x0 电信 中兴 ZXHN F650超级用户 用户名：telecomadmin 密码：nE7jA%5m","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"modem","slug":"modem","permalink":"https://boypt.github.io/tags/modem/"},{"name":"光猫","slug":"光猫","permalink":"https://boypt.github.io/tags/%E5%85%89%E7%8C%AB/"},{"name":"HG6821M","slug":"HG6821M","permalink":"https://boypt.github.io/tags/HG6821M/"}]},{"title":"在路由器iptables中匹配IPv6动态地址","slug":"match-ipv6","date":"2018-10-24T07:59:18.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2018/10/24/match-ipv6/","link":"","permalink":"https://boypt.github.io/2018/10/24/match-ipv6/","excerpt":"家用宽带目前很多都部署了IPv6，家用路由器目前Padavan/Openwrt等系统都能较好地支持了IPv6。不过要充分利用IPv6链接设备，有些坑。","text":"家用宽带目前很多都部署了IPv6，家用路由器目前Padavan/Openwrt等系统都能较好地支持了IPv6。不过要充分利用IPv6链接设备，有些坑。 动态变化的IPv6地址首先是IPv6地址，不同设备（操作系统）获取的IPv6地址有区别，较为通用的是【无状态EUI-64地址】，操作系统通过网卡的mac地址生成一个64位固定后缀，以及路由器下发的64位前缀，合成一个固定的IPv6地址。 作为服务端，【无状态EUI-64地址】是较为适合的，Linux发行版很多组件（systemd-netword，dhcpcd等）默认都采用EUI-64地址。 另外还有通过DHCPv6下发的地址，可以通过设置静态分发，对应设备（DUID）下发特定地址。作为服务器地址最适合的方式。 此外，家用宽带ISP提供的IPv6前缀是不定期变化的。可见要访问家庭宽带内网的设备，光是地址就存在了蛮多的变化因素。 IPv6的【隐私扩展地址】终端设备，比如手机、工作站版本Windows等设备，则使用【隐私扩展】的方式随机生成64位后缀，这样终端的地址每次链接时候都会随机改变，访问外部资源时候可避免被追踪。 如果要连接Windows远程桌面，安装的是工作站版本，系统默认已经启用【隐私扩展】，主机地址就是随机变化的，想要连接3389就很麻烦了，不过这个特性可以关闭。服务器版本的Windows默认不启用隐私扩展，而家庭版Windows不支持远程桌面[doge]。 管理员权限的CMD下执行 1234netsh interface ipv6 set global randomizeidentifiers=disabled store=active netsh interface ipv6 set global randomizeidentifiers=disabled store=persistent netsh interface ipv6 set privacy state=disabled store=active netsh interface ipv6 set privacy state=disabled store=persistent IPv6防火墙ip6tables要从外网通过IPv6访问家里路由器下的设备，最关键一点是路由器上的防火墙要允许这样的转发。 Padavan/Openwrt都是基于Linux - ip6tables的防火墙。 默认情况下，只允许了v6子网内的设备被ping，只允许特定类型的ICMPv6报文通过转发，其他通信报文一律丢弃了。所以虽然IPv6下每个设备都有公网地址，但是还不至于不安全到每个设备都可让人随便连。 动态匹配EUI-64后缀考虑到前缀变化因素，要访问特定设备，就是让IPTABLES匹配特定设备的EUI-64后缀放通这个地址： 1ip6tables -I FORWARD -d ::abcd:1234:5678:90ef/::ffff:ffff:ffff:ffff -j ACCEPT 可见iptables对v6地址的匹配掩码可以非常灵活，不像v4下只按前缀适配。坑的就是这个特征是没有文档的，目前文档中写的mask解释还是适配IPv4的内容，有人专门发邮件去netfilter列表问了才知道。IPv6地址中，双冒号::的写法代表是前/后均为0位，双冒号只能出现一次。 动态匹配DHCPv6固定后缀对于内网服务器，可以设置DHCPv6进行固定网段后缀分配，比如 12345240e:1234:5678:1234::1024:101240e:1234:5678:1234::1024:102240e:1234:5678:1234::1024:103240e:1234:5678:1234::1024:104... 在路由器上可以一个命令匹配 1ip6tables -I FORWARD -d ::1024:0000/::ffff:0000 -j ACCEPT Openwrt中配置转发规则 Padavan中设置转发规则其实padavan中的防火墙功能并没有配置地址匹配转发规则的功能界面，只能在自定义脚本中写原始的iptables命令。截图中使用的padavan是增加了QOS组件的老毛子版本。 以上。","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://boypt.github.io/tags/iptables/"},{"name":"address","slug":"address","permalink":"https://boypt.github.io/tags/address/"},{"name":"ipv6","slug":"ipv6","permalink":"https://boypt.github.io/tags/ipv6/"},{"name":"suffix","slug":"suffix","permalink":"https://boypt.github.io/tags/suffix/"}]},{"title":"iptables笔记","slug":"iptables","date":"2018-09-07T02:39:44.000Z","updated":"2021-10-22T06:20:27.421Z","comments":true,"path":"2018/09/07/iptables/","link":"","permalink":"https://boypt.github.io/2018/09/07/iptables/","excerpt":"iptables笔记","text":"iptables笔记 Packet Flow Chart Netfilter Flow Chart Firewall Rules12apt install iptables-persistent NAT as port forwarding1234567891011# 数据包进入PREROUTING Chain，DNAT修改来源数据包的目的地址/端口为映射的$DEST_IP:$PORTiptables -t nat -A PREROUTING -p tcp --dst $WAN_IP --dport 80 -j DNAT --to-destination $DEST_IP:$PORT# 此时Packet的目的地址不是本机地址，而是$DEST_IP，进入filter表的FORWARD Chain进行规则审核，要允许其通过（若filter表已是默认允许的，可以忽略本条）iptables -A FORWARD -p tcp --dst $DEST_IP --dport $PORT -j ACCEPT# 进入POSTROUTING Chain，SNAT修改数据包中的来源地址为本网关；若目的机的默认网关就是本机，可以忽略本步（因为如果是目的机的默认网关，不管发往哪里的包都是发回来本网关；不然的话会发去了另外一个网关，无法成为相同一个NAT会话，无法通信）。默认网关的方式不用这句时目标机可以看到来源的真实地址。iptables -t nat -A POSTROUTING -p tcp --dst $DEST_IP --dport 80 -j SNAT --to-source $LAN_IP# 在网关本机和内网其他机器访问WAN_IP这个端口映射，数据包产生在OUTPUT Chain，需要做和PREROUTING相同的操作才能访问到（若不需要，可忽略本步）iptables -t nat -A POSTROUTING --dst $WAN_IP -p tcp --dport 80 -j DNAT --to-destination $DEST_IP:$PORT NAT as gatewayEnable IP Forwarding 12sed -i &#x27;s/.*net\\.ipv4\\.ip_forward.*/net.ipv4.ip_forward = 1/&#x27; /etc/sysctl.confsysctl -p MASQUERADE, pppoe等动态IP环境使用环境 1iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j MASQUERADE or SNAT, 静态外网IP, 或出口网卡绑定了多个IP时候使用 1iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j SNAT --to-source &lt;IP&gt; 自动调整经pppoe-wan接口发出的TCP数据MSS, PPP链路情况 1iptables -t mangle -I POSTROUTING -o pppoe-wan -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu NAT as proxy （双向NAT，举例推特API服务器hosts转发）123456iptables -t nat -A PREROUTING -d [YOUR SERVER IP] -p tcp -m tcp --dport 443 -j DNAT --to-destination 199.59.148.20:443 iptables -t nat -A POSTROUTING -d 199.59.148.20 -p tcp -m tcp --dport 443 -j SNAT --to-source [YOUR SERVER IP]iptables -A FORWARD -d 199.59.148.20 -p tcp -m tcp --dport 443 -j ACCEPT iptables -A FORWARD -s 199.59.148.20 -p tcp -m tcp --sport 443 -m state --state RELATED,ESTABLISHED -j ACCEPT Iptables Firewall 后 FTP 服务 List 命令超时12modprobe ip_conntrack_ftpecho &quot;ip_conntrack_ftp&quot; &gt;&gt;/etc/modules Filter DNS from GFW12iptables -A INPUT --source 8.8.8.8,8.8.4.4 -p udp --source-port 53 -m dscp ! --dscp 0x00 -j DROPiptables -A INPUT --source 8.8.8.8,8.8.4.4 -p udp --source-port 53 -m ttl --ttl-gt 48 -j DROP Quick fix for deprecated state module [since Dec 2012]1sed -i &quot;s/-m state --state/-m conntrack --ctstate/g&quot; /etc/iptables/iptables.rules","categories":[{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://boypt.github.io/tags/iptables/"},{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/tags/linux/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/categories/linux/"},{"name":"networking","slug":"networking","permalink":"https://boypt.github.io/categories/networking/"},{"name":"Networking","slug":"Networking","permalink":"https://boypt.github.io/categories/Networking/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://boypt.github.io/tags/linux/"},{"name":"raspberry","slug":"raspberry","permalink":"https://boypt.github.io/tags/raspberry/"},{"name":"networking","slug":"networking","permalink":"https://boypt.github.io/tags/networking/"},{"name":"webdav","slug":"webdav","permalink":"https://boypt.github.io/tags/webdav/"},{"name":"openvpn","slug":"openvpn","permalink":"https://boypt.github.io/tags/openvpn/"},{"name":"openwrt","slug":"openwrt","permalink":"https://boypt.github.io/tags/openwrt/"},{"name":"docker","slug":"docker","permalink":"https://boypt.github.io/tags/docker/"},{"name":"sdk","slug":"sdk","permalink":"https://boypt.github.io/tags/sdk/"},{"name":"wifi","slug":"wifi","permalink":"https://boypt.github.io/tags/wifi/"},{"name":"wireless","slug":"wireless","permalink":"https://boypt.github.io/tags/wireless/"},{"name":"ar5b22","slug":"ar5b22","permalink":"https://boypt.github.io/tags/ar5b22/"},{"name":"rouer","slug":"rouer","permalink":"https://boypt.github.io/tags/rouer/"},{"name":"dw33d","slug":"dw33d","permalink":"https://boypt.github.io/tags/dw33d/"},{"name":"xunlei","slug":"xunlei","permalink":"https://boypt.github.io/tags/xunlei/"},{"name":"router","slug":"router","permalink":"https://boypt.github.io/tags/router/"},{"name":"‎PXH11RWA","slug":"‎PXH11RWA","permalink":"https://boypt.github.io/tags/%E2%80%8EPXH11RWA/"},{"name":"modem","slug":"modem","permalink":"https://boypt.github.io/tags/modem/"},{"name":"光猫","slug":"光猫","permalink":"https://boypt.github.io/tags/%E5%85%89%E7%8C%AB/"},{"name":"HG6821M","slug":"HG6821M","permalink":"https://boypt.github.io/tags/HG6821M/"},{"name":"iptables","slug":"iptables","permalink":"https://boypt.github.io/tags/iptables/"},{"name":"address","slug":"address","permalink":"https://boypt.github.io/tags/address/"},{"name":"ipv6","slug":"ipv6","permalink":"https://boypt.github.io/tags/ipv6/"},{"name":"suffix","slug":"suffix","permalink":"https://boypt.github.io/tags/suffix/"}]}